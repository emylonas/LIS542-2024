<?xml version="1.0" encoding="UTF-8"?>
<!-- To build schemas and doc from this, try Syd's fiumicino.bash command    -->
<!-- WARNING: because we don't use the TEI namespace, the output .isosch     -->
<!--    file needs to be hand-edited. In particular, change "tei:" to "wwp:" -->
<!--    passim. (Note: remember to make that change CASE SENSITIVELY, as we  -->
<!--    use both "tei:" and "TEI:", and we don't want to change the latter.) -->
<TEI xmlns="http://www.tei-c.org/ns/1.0" xml:lang="en"
    xmlns:sch="http://purl.oclc.org/dsdl/schematron"
    xmlns:sqf="http://www.schematron-quickfix.com/validator/process"
    xmlns:rng="http://relaxng.org/ns/structure/1.0" >
  <teiHeader>
    <fileDesc>
      <titleStmt>
        <title>Northeastern University Women Writers Project Textbase Encoding Language</title>
        <author xml:id="sb" ref="p:sbauman.emt">Syd Bauman</author>
      </titleStmt>
      <editionStmt>
        <edition n="5.76.0">$Id: wwp-store.odd 44958 2022-03-02 00:04:46Z syd $</edition>
      </editionStmt>
      <publicationStmt>
        <publisher>Northeastern University Women Writers Project</publisher>
        <availability>
          <p>© 2008 Northeastern University Women Writers Project</p>
          <licence>
            <ref target="https://creativecommons.org/licenses/by-sa/4.0/">
              <choice>
                <expan>Creative Commons Attribution-ShareAlike 4.0 International</expan>
                <abbr>CC BY-SA 4.0</abbr>
              </choice>
            </ref>
          </licence>
        </availability>
      </publicationStmt>
      <sourceDesc>
        <p>No source, this ODD document is the original. However, this
        file is heavily based on EMPB.</p>
      </sourceDesc>
    </fileDesc>
    <revisionDesc>
      <change n="5.76.0" who="#sb" when="2022-02-24">
        Add constraints <name>LessThan3InitialCharsDropped</name>
        &amp; <name>idealSignature</name> and write a description for
        the <val>sig</val> value of <att>unit</att> of
        <gi>milestone</gi>. Also remove elements no longer in P5’s
        <name>gaiji</name> module from list of elements included from
        that module.
      </change>
      <change n="5.75.0" who="#sb" when="2022-01-27">
        Per today's encoding meeting, add <val>other</val> as a
        possible value of <att>desc</att> of <gi>gap</gi>, and require
        that any <gi>gap</gi> so described have an explanatory
        <gi>note</gi>.
      </change>
      <change n="5.74.0" who="#sb" when="2021-06-29">
        Changes to enumerated values of <att>type</att> of
        <gi>note</gi> (including better descriptions).
      </change> 
      <change n="5.73.0" who="#sb" when="2021-06-28">
        Allow <gi>div</gi>’s content model to be satisfied if one of
        the required elements is a descendent (not just a child), but
        only if it is not inside an <gi>epigraph</gi>.
      </change>
      <change n="5.72.0" who="#sb" when="2021-06-22">
        Add <val>internal</val> (and some descriptions) to
        <att>type</att> of <gi>note</gi>.
      </change>
      <change n="5.71.0" who="#sb" when="2021-06-21">
        Put <gi>floatingText</gi> into <name>mode.notePart</name>, thus allowing it
        as a child of <gi>note</gi>. (TEI allows it, and thus this had been a long-
        standing corrigible error IMHO.)
      </change>
      <change n="5.70.1" who="#sb" when="2021-05-25">
        Fix <name>TR_and_OT_nums</name> so that it works whether
        defaulted attriubte values are present or not. (I.e., this new
        version will work even when oXygen's XML > XML Parser > RELAX
        NG > Add default attribute values box is checked.) Thanks to
        <persName ref="p:bmohler.hcu"/> and <persName
        ref="p:omastrosi.uer"/> for helping me (re-)find the problem.
      </change>
      <change n="5.70.0" who="#sb" when="2021-05-11">
        Per various encoding meeting discussions:
        <list>
          <item>Remove constraint (in <name>datingAttr</name>) that a temporal
          normalization attribute is required if there is a <att>calendar</att>; and</item>
          <item>add <gi>floatingText</gi> to content model of <gi>note</gi>.</item>
        </list>
        Note that the latter was done by removing <name>model.quoteLike</name> from
        <name>model.notePart</name> and adding <name>model.attributable</name>, the
        result being that <gi>said</gi> is allowed as a direct child of <gi>note</gi>,
        too.
      </change>
      <change n="5.69.0" who="#sb" when="2021-01-31">
        Per SC request for <gi>author</gi> inside <gi>rs</gi>, add it
        to <name type="class">macro.phraseSeq</name>.
      </change>
      <change n="5.68.0" who="#sb" when="2021-01-28">
        Per SC &amp; JF at meeting, add <val>wwp:corvey</val> to
        <att>type</att> of <gi>idno</gi>, and a paragraph in its
        <gi>remarks</gi>.
      </change>
      <change n="5.67.0" who="#sb" when="2021-01-19">
        Add <gi>translator</gi>. (Change started 2021-01-14.)
      </change>
      <change n="5.66.1" who="#sb" when="2020-12-15">
        Improve <ident>persName-refers-to-person</ident> code so that
        it does not bomb out with a fatal error if there are 2 or more
        tokens that do not match the <q>p:aaaaaaaa.bbb</q> pattern.
      </change>
      <change n="5.66.0" who="#sb" when="2020-12-15">
        Per meeting with Sarah and Ash, add new set of values to
        <att>type</att> of <gi>idno</gi> for some digital
        resources.</change>
      <change n="5.65.0" who="#sb" when="2020-12-13">
        Encoder <persName key="p:gomara.nsf">Grace O’Mara</persName>
        found that our recommended method of encoding a <gi>date</gi>
        that overlaps logical structures (which is to use
        <att>next</att> and <att>prev</att>, putting the temporal
        attribute(s) on the first <gi>date</gi> of the series) causes
        a warning because the partial <gi>date</gi> elements (other than
        the first) do not have any temporal attributes.
      </change>
      <change n="5.64.1" who="#sb" when="2020-11-17">
        <p>Per encoding meeting add remarks to <gi>date</gi> that
        discuss how to encode B.C. (aka BCE) dates.</p>
      </change>
      <change n="5.64.0" who="#sb" when="2020-11-13">
        Constraint <att>who</att> of <gi>change</gi> to 1–6 prefixed name keys.
        Also require <att>when</att> of <gi>change</gi>.
      </change>
      <change n="5.63.0" who="#sb" when="2020-11-12">
        Incorporate <name
        type="file">supraSchemas/rendLadder-keyword-checker.sch</name>.
        That is, we now test (using 2 calls to an abstract pattern)
        the keywords used in rendition ladders EXCEPT those that are
        used inside <val>bequeath</val> or <val>bestow</val>.
      </change>
      <change n="5.62.0" who="#sb" when="2020-11-12">
        Per encoding meeting, add <val>person</val> to <att>type</att>
        of <gi>rs</gi>
      </change>
      <change n="5.61.1" who="#sb" when="2020-11-03">
        With SC, improve warning message displayed when XInclude
        processing has not been performed.
      </change>
      <change n="5.61.0" who="#sb" when="2020-10-16">
        Add <val>wimauma</val> to list of libraries
      </change>
      <change n="5.60.0" who="#sb" when="2020-08-10">
        Allow <gi>argument</gi> inside <gi>item</gi>
      </change>
      <change n="5.59.1" who="#sb" when="2020-07-21">
        Bug fix: had two separate <gi>elementSpec</gi>s for
        <gi>date</gi> (from change for 5.5.9.0, 2020-07-19); combined
        them.
      </change>
      <change n="5.59.0" who="#sb" when="2020-07-19">
        Constrain <att>cert</att> on <gi>date</gi> with
        <ident>cert_on_date</ident>: only allow <val>low</val>, and
        only if the <gi>date</gi> is inside a
        <gi>publicationStmt</gi>. This is because we actually plan to
        <emph>use</emph> <att>cert</att> on <gi>date</gi> on rare
        occasion. :-)
      </change>
      <change n="5.58.0" who="#sb" when="2020-07-11">
        Per e-mail from Sarah add Boston Athenæum to list of
        <att>type</att> on <gi>idno</gi>.
      </change>
      <change n="5.57.0" who="#sb" when="2020-04-07">
        Add <name>note_with_only_add_should_be_add_with_note</name> constraint.
      </change>
      <change n="5.56.1" who="#sb" when="2020-04-05">
        Corrected erroneous WWP namespace prefixes
      </change>
      <change n="5.56.0" who="#sb" when="2020-04-04">
        Add <val>ufo</val> to the newly required <att>type</att> of <gi>rs</gi>.
      </change>
      <change n="5.55.0" who="#sb" when="2020-04-03">
        Per request Sarah, make <att>type</att> of <gi>rs</gi> required.
      </change>
      <change n="5.54.0" who="#sb" when="2020-02-27">
        Add <name>avoid_model.divTop_in_middle</name> Schematron test.
      </change>
      <change n="5.53.0" who="#sb" when="2020-02-20">
        Add new <att>value</att> to <gi>mapping</gi> in anticipation that TEI
        will add it, or something equivalent.
      </change>
      <change n="5.52.0" who="#sb" when="2020-02-20">
        Ooops. New encoding of <gi>char</gi> requires the <gi>desc</gi> element,
        which we had not been using. Added it.
      </change>
      <change n="5.51.0" who="#sb" when="2019-12-12">
        Per encoding meeting, makeing <att>xml:lang</att> of
        <gi>foreign</gi> required.
      </change>
      <change n="5.50.0" who="#sb" when="2019-08-12">
        Per encoding meeting, add <val>issue</val> and
        <val>commentary</val> to list of values of <att>type</att> of
        <gi>ab</gi>.
      </change>
      <change n="5.49.0" who="#sb" when="2019-07-22">
        Per Sarah, added <val>p:collective</val> to possible values of
        <att>author</att> of <name
        type="class">att.declaring</name>.
      </change>
      <change n="5.48.2" who="#sb" when="2019-05-20">
        Swap definitions of <val>prop</val> and <val>present</val> in
        value list for <att>type</att> of <gi>stage</gi>.
      </change>
      <change n="5.48.1" who="#sb" when="2019-05-20">
        Use phrase-level encoding in Jake's change log entry, below;
        fix a few minor invalidities according to tei_customization.rnc.
      </change>
      <change n="5.48.0" who="p:jmurel.tyw" when="2019-05-20">
        <list>
          <item>Per today's encoding meeting, change <gi>bibl</gi> to
          allow <gi>epigraph</gi> inside.</item>
          <item>Further, per Syd's
          instructions, correct some validity errors:
          <list>
            <item>Removed <att>type</att> from <gi>macroSpec</gi> for
            <name>macro.anyXML</name> under <q>Class and Macro
            manipulation</q> section.</item>
            <item>Removed mentions of <name>verse</name> module in
            <q>Class Deletion</q> section as schema does not use that
            module.</item>
          </list>
          </item>
        </list>
      </change>
      <change n="5.47.0" who="#sb" when="2019-04-18">
        Per meeting w/ Sarah on 2019-04-02, remove <att>ref</att> of
        <gi>quote</gi>, and add not to <att>cit</att> of
        <gi>quote</gi> that we are not currently using it.
      </change>
      <change n="5.46.1" who="#sb" when="2019-04-09">
        Modify <name>persName-refers-to-person</name> constraint so
        that <att>author</att> (on att.declarable elements) is added
        to set of attrs checked for pointing to a <gi>person</gi>.
      </change>
      <change n="5.46.0" who="#sb" when="2019-04-09">
        Add new <att>author</att> to att.declaring, and make
        <gi>postscript</gi> a member of that class. Have not added
        Schematron to ensure it points to a <gi>person</gi>,
        yet.
      </change>
      <change n="5.45.0" who="#sb" when="2019-03-12">
        Per encoding meeting of today, change the
        <val>paraphrase</val> value of <att>type</att> of
        <gi>quote</gi> to <val>adaptation</val> (so we can use
        <val>paraphrase</val> for something different in
        MME).
      </change>
      <change n="5.44.1" who="#sb" when="2019-02-27">
        Per staff meeting of 2019-02-14, updated discussion of use of
        <att>source</att>. WINITA.
      </change>
      <change n="5.44.0" who="#sb" when="2019-02-19">
        Per encoding meeting of 2019-02-19, add
        <val>collectivity</val> as possible value of <att>type</att>
        of <gi>rs</gi>.
      </change>
      <change n="5.43.0" who="#sb" when="2019-01-24">
        <list>
          <item>Per encoding meeting of circa 2018-12-18, add <val>place</val>
          as possible value of <att>type</att> of <gi>rs</gi>.</item>
          <item>Per request Sarah, add <gi>list</gi> to content of
          <gi>bibl</gi>; see, e.g., p. 131 of butler.irish.xml (PDF
          page 156 of ot.butler.irish.pdf).</item>
        </list>
      </change>
      <change n="5.42.1" who="#sb" when="2019-01-17">
        Comment out Schematron Quick Fix that was causing an error in
        pre-20 versions of oXygen. See the <gi>desc</gi> of the
        <gi>elementSpec</gi> for <gi>mw</gi>.</change>
      <change n="5.42.0" who="#sb" when="2018-12-04">
        Per encoding meeting, add <val>other</val> to closed list of
        possible values of <att>reason</att> of <gi>supplied</gi>
      </change>
      <change n="5.41.0" who="#sb" when="2018-11-29">
        Add <name>date_in_docDate</name> Schematron test to warn encoders
        when a <gi>date</gi> is inside a <gi>docDate</gi>. If it looks like
        the <gi>docDate</gi> has other content besides the
        <gi>date</gi>, issue a warning; if it looks like they have the
        same content issue an error.
      </change>
      <change n="5.40.0" who="#sb" when="2018-11-14">
        Add <name>catchword_delimiters_in_content</name> Schematron
        test to require that delimiters of catchwords be put in the
        content of the <gi>mw</gi>, not on the <att>rend</att>. Note
        that the quick fix does <emph>not</emph> work correctly when
        the content of the <val>pre()</val> or <val>post()</val>
        contains regular expression special characters (like
        <mentioned>)</mentioned> or <mentioned>.</mentioned>), in at
        least some (perhaps most, but not all) cases. Same holds for
        when there are child elements.
      </change>
      <change n="5.39.2" who="#sb" when="2018-08-21">
        I now have a regexp for <att>selector</att> that I am pretty sure works. However:
        <list><label>a)</label><item>it permits <val>two\ words</val>, which perhaps it should not, and</item><label>b)</label><item>it is designed for any CSS level 3 selector, probably should be re-written to be far more strict for our purposes; but it is already 18,721 characters long.</item></list>
      </change>
      <change n="5.39.1" who="#sb" when="2018-08-20">
        Revert long regexp for <att>selector</att> until I have a RELAX NG version that works
      </change>
      <change n="5.39.0" who="#sb" when="2018-08-13">
        <list>
          <item>Use new <emph>long</emph> regexp for testing value
          of <att>selector</att></item>
          <item>Add controlled vocabulary to (now required)
          <att>type</att> of <gi>spGrp</gi>; list generated on Skype
          call with Sarah and Ahsley</item>
        </list>
      </change>
      <change n="5.38.1" who="#sb" when="2018-06-11">
        Add <val>*-custom</val> to list of temporal normalization attrs, as we do on rare
        occasion use them.
      </change>
      <change n="5.38.0" who="#sb" when="2018-05-29">
        Add <val>Vv</val> to possible values of <gi>vuji</gi>
      </change>
      <change n="5.37.4" who="#sb" when="2018-04-23">
        Bug fix: we now require https when getting ogrophy files, etc.
      </change>
      <change n="5.37.3" who="#sb" when="2018-04-23">
        Seems previous change got rid of <att>extent</att> of <gi>gap</gi>, so put it back
      </change>
      <change n="5.37.2" who="#sb" when="2018-04-03">
        Untied from 3.0.0, as we no longer use <att>render</att>. This gives
        us <att>source</att> on <gi>bibl</gi>.
      </change>
      <change n="5.37" who="#sb" when="2018-02-17">
        Ensure that <gi>salute</gi> and <gi>signed</gi> are always
        within <gi>opener</gi> or <gi>closer</gi>, by removing them
        from <name type="class">model.divWrapper</name> and from <name
        type="class">model.divBottomPart</name> and <name
        type="class">model.divTopPart</name>, respectively. .
      </change>
      <change n="5.36.0" who="#sb" when="2018-02-17">
        Add Schematron checks on new <att>type</att> of <val>metawork</val> on <gi>sic</gi>:
        <list>
          <item><ident>no_correction_of_erroneous_metawork</ident></item>
          <item><ident>no_content_in_erroneous_metawork_flag</ident></item>
        </list>
      </change>
      <change n="5.35.0" who="#sb" when="2018-02-16">
        Loosen grammar constraint that <att>target</att> of
        <gi>anagram</gi> have 2 pointers, and add a rule constraint
        that it have either 1 pointer and content, or 2+ pointers and
        no content.
      </change>
      <change n="5.34.0" who="#sb" when="2018-02-14">
        Allow phrase-level content in <gi>anagram</gi>
      </change>
      <change n="5.33.0" who="#sb" when="2018-02-12">
        Add <val>metawork</val> as a value of <att>type</att> of <gi>sic</gi>
      </change>
      <change n="5.32.0" who="#sb" when="2018-01-06">
        <list>
          <item>Add clause to regexp that tests <att>rend</att> so
          that <mentioned>⸿</mentioned> is considered valid. (This, as
          far as I can tell, is an error in jing, as
          <mentioned>⸿</mentioned> is in the Unicode <name
          type="ident">punctuation, other</name> character class
          (<name type="ident">Po</name> for short), and thus should be
          valid against TEI’s <name
          type="class">att.global.rendition</name> already.)
          </item>
        </list>
      </change>
      <change n="5.32.0" who="#sb" when="2018-01-04">
        <list>
          <item>Add constraints to check that the TR number on
          <att>xml:id</att> of <gi>floatingText</gi> or other nexted
          sub-<gi>text</gi> matches that on the main
          <gi>text</gi></item>
          <item>Remove default value from <att>type</att> of
          <gi>titlePart</gi> and make it required.</item>
          <item>Put <gi>regMe</gi> into <name
          type="class">att.canonical</name> in order to give it
          <att>ref</att>.</item>
        </list>
      </change>
      <change n="5.31.2" who="#sb" when="2017-12-10">
        Per <ref target="https://trello.com/c/1G8XrNip/232-ttd">Trello
        card</ref>, removed lots of unused elements.
      </change>
      <change n="5.31.1" who="#sb" when="2017-11-02">
        Per (and at) encoding meeting, added <q>items-point-internally</q> constraint
      </change>
      <change n="5.30.0" who="#sb" when="2017-10-25">
        Per last week's staff meeting, remove
        <ident>choice-children</ident> constraint and instead just
        tighten up the content model of <gi>choice</gi> to
        <code lang="rnc">
       ( sic,      corr+        )
     | ( abbr,     expan+       )
     | ( orig,     reg+         )
     | ( unclear,  unclear+     )
     | ( supplied, supplied+    )
        </code>
        as we never use <gi>seg</gi> or <gi>choice</gi> as a child of
        <gi>choice</gi>, and encoders are very consistent, and always
        put things in a certain order, anyway. However, we do feel
        there is some chance we would want to allow multiple
        corrections, expansions, or regularized readings.
      </change>
      <change n="5.29.0" who="#sb" when="2017-10-12">
        Per conversation w/ Sarah, add constraint <ident>choice-children</ident>
      </change>
      <change n="5.28.0" who="#sb" when="2017-09-14">
        Per encoding meeting modify value list of <att>type</att> of
        <gi>docRole</gi>: remove <val>disseminator</val> and add
        <val>printer-publisher</val>.
      </change>
      <change n="5.27.0" who="#sb" when="2017-07-25">
        Per encoding meeeting add <val>remix</val> to values of <att>type</att> of <gi>quote</gi>
      </change>
      <change n="5.26.0" who="#sb" when="2017-06-19">
        Per Sarah:
        <list>
          <item>Add Boston Public Library to list of libraries for <att>type</att> of <gi>idno</gi></item>
          <item>Add <val>dramatic-verse</val> to values of <att>subtype</att> of <gi>lg</gi></item>
          <item>Remove <gi>pause</gi> and add <gi>space</gi></item>
        </list>
      </change>
      <change n="5.25.2" who="#sb" when="2017-05-29">
        Oops. Discovered that there are <gi>rendition</gi> elements
        that, because they are pointed to by <att>rendition</att>
        attributes (because the rendition in question contains
        <gi>g</gi>), are <emph>not</emph> supposed to have a <att>selector</att>.
        While here, only check for <att>ref</att> of <gi>g</gi> iff there
        exists a /TEI/teiHeader/encodingDesc/listPrefixDef, thus indicating
        that XInclude processing has been performed.
      </change>
      <change n="5.25.1" who="#sb" when="2017-05-28">
        Continuing on yesterday, add requirement that
        <att>selector</att> be present on <gi>rendition</gi>, and
        constrain it using a first-crack at a regex for
        selectors.
      </change>
      <change n="5.25.0" who="#sb" when="2017-05-27">
        Changes for change in default rendition indication in P5:
        <list>
          <item>Remove <gi>namespace</gi> and <gi>tagUsage</gi></item>
          <item>Remove changes to <gi>namespace</gi></item>
          <item>Remove changes to <gi>tagUsage</gi></item>
          <item>Change some_must_have_rend to use new mechanism</item>
        </list>
      </change>
      <change n="5.24.2" who="#sb" when="2017-05-17">
        Bug fixes:
        <list>
          <item>'twas missing a namespace prefix in a Schematron constraint</item>
          <item>The test for <att>xml:id</att> uniqueness was being
          fired on any element, rather than on <att>xml:id</att>s; fix
          by adding an <gi>sch:rule</gi></item>
        </list>
      </change>
      <change n="5.24.1" who="#sb" when="2017-05-15">
        revert change 5.13.0 of 2016-11-01, as we've decided to move
        this test to a post-encoding test; see
        ../supraSchemas/mw_sp_stage_specify_break.sch.
      </change>
      <change n="5.24.0" who="#sb" when="2017-05-09">
        Add <gi>pause</gi> as per encoding meetings of <date
        when="2015-02-12"/> and <date when="2015-04-13"/>, <date
        when="2015-10-21"/>.
      </change>
      <change n="5.23.5" who="#sb" when="2017-05-02">
        <list>
          <item>Remove <val>UNKNOWN</val> from <att>type</att> of <gi>stage</gi></item>
          <item>Add descriptions to defs of values of <att>type</att> of <gi>stage</gi></item>
        </list>
      </change>
      <change n="5.23.4" who="#sb" when="2017-05-02">
        Bug fix: Change <val>change</val> to <val>replace</val> on
        <att>mode</att> of definition of <att>type</att> of
        <gi>stage</gi>
      </change>
      <change n="5.23.2" who="#sb" when="2017-04-08">
        Officially CC BY-SA 4.0 now
      </change>
      <change n="5.23.1" who="#sb" when="2017-03-22">
        <p>Add Schematron Quick Fix for tests added yesterday.</p>
      </change>
      <change n="5.23.0" who="#sb" when="2017-03-21">
        <p>Per encoding meeting, add tests so that all aggregate
        elements assembled by pointing with <att>next</att> or
        <att>prev</att> use both <att>next</att> and <att>prev</att>.
        (I.e., uses double-linked lists).</p>
      </change>
      <change n="5.22.0" who="#sb" when="2017-03-16">
        <p>Per Sarah's request, add <gi>emph</gi> to list of elements that
        are flagged as an error iff no rendition (default or specified).</p>
      </change>
      <change n="5.21.0" who="#sb" when="2017-03-15">
        <p>Per e-mail exchange <title>Encoding question</title> (and
        phone conversation) with Sarah, revert 4.6.0 of
        <date>2015-07-01</date>, as in the interim TEI has (perhaps
        unwisely) allowed multiple values on <att>type</att> of
        <gi>stage</gi>.</p>
      </change>
      <change n="5.20.0" who="#sb" when="2017-01-31">
        Per e-mail from Sarah of today and encoding meeting of today:
        <list>
          <item>change <val>illegible</val> to <val>obscured</val>,</item>
          <item>remove <val>deleted</val> from controled value list of <att>reason</att> of <gi>gap</gi>, and</item>
          <item>make <att>extent</att> of <gi>gap</gi> required.</item>
        </list>
        <emph>Also</emph> had to tie this to version 3.0.0 of TEI P5, as version 3.1.0 does not
        have a <att>render</att> attribute, which we still use.
      </change>
      <change n="5.19.0" who="#sb" when="2016-12-25">
        <list>
          <item>allow <gi>calendar</gi> and thus <gi>calendarDesc</gi></item>
          <item>check that <att>calendar</att> points to a <gi>calendar</gi></item>
          <item>check that <att>render</att> of <gi>tagUsage</gi> points to a <gi>rendition</gi></item>
          <item>check that <att>ref</att> of <gi>placeName</gi> points to <gi>place</gi></item>
          <item>bug fix: move an <gi>sch:let</gi> from child of
          <gi>sch:pattern</gi> to child of <gi>sch:rule</gi> both in a
          pre-existing <gi>constraint</gi> and in a new one, because
          otherwise Schematron complaints about it being delcared
          twice.</item>
        </list>
      </change>
      <change n="5.18.0" who="#sb" when="2016-12-17">
        <list>
          <item n="30354">Add tests on the filename (actual, if
          available, vs. that specified on the <gi>idno</gi> in the
          header, vs. that given by Subversion).</item>
          <item n="30355">Add test that <att>spanTo</att> points to an <gi>anchor</gi>.</item>
        </list>
      </change>
      <change n="5.17.0" who="#sb" when="2016-12-15">
        Added a test that <att>who</att> of <gi>sp</gi> points to a <gi>role</gi>
      </change>
      <change n="5.16.0" who="#sb" when="2016-12-14">
        <list>
          <item>Add test that <gi>note</gi>s inside <gi>hyperDiv</gi>
          or a <gi>div</gi> with <att>type</att> <val>endnotes</val>
          have <att>target</att>.</item>
          <item>Add test that a <gi>hi</gi> or <gi>mcr</gi> must have a rendition
          (either default or specified on <att>rend</att>) that contains a <mentioned>(</mentioned>
          character. (Yeah, it should also contain a <mentioned>)</mentioned> character, but
          the routine to check for balanced parens in <att>rend</att> will catch that.)</item>
        </list>
      </change>
      <change n="5.15.0" who="#sb" when="2016-11-30">
        Per request Sarah (and rest of encoders at today's meeting),
        add test so that we do not flag <gi>mw</gi> sans
        <val>break()</val> if it immediately follows either
        <gi>pb</gi> or <gi>milestone</gi>.
      </change>
      <change n="5.14.0" who="#sb" when="2016-11-02">
        Add constraint on <att>name</att> of <gi>namespace</gi>: it has to be ours.
      </change>
      <change n="5.13.0" who="#sb" when="2016-11-01">
        Per encoding meeting a week or two ago, add test to ensure
        <gi>mw</gi>, <gi>sp</gi>, and <gi>stage</gi> elements have
        <val>break()</val> specified, either on their <att>rend</att>
        or via renditional default.
      </change>
      <change n="5.12.0" who="#sb" when="2016-10-12">
        <list>
          <item>Require <att>ref</att> on <gi>persName</gi> child of <gi>author</gi> when inside <gi>teiHeader</gi>.</item>
          <item>Add warning iff <gi>listPrefixDef</gi> cannot be found</item>
          <item>Per today's encoding meeting, add <val>undetermined</val> to value list of <att>type</att> on <gi>quote</gi></item>
        </list>
      </change>
      <change n="5.11.0" who="#sb" when="2016-10-05">
        Add <att>gender</att> to <gi>castGroup</gi> and <gi>castItem</gi>; explain
        rules for defaulting.
      </change>
      <change n="5.10.0" who="#sb" when="2016-09-21">
        <list>
          <item>Per encoding meeting, added <val>verb</val> to list of values
          for <att>type</att> of <gi>rs</gi></item>
          <item>bug fix: <ident>TR_and_OT_nums</ident> was not
          checking <att>xml:id</att> of <gi>teiHeader</gi></item>
          <item>bug fix: constraint <att>type</att> of <gi>ab</gi></item>
        </list>
      </change>
      <change n="5.9.1" who="#sb" when="2016-09-16">
        Discovered that although the change log entry (for 2016-07-06,
        below) says we moved <gi>elision</gi> from <name
        type="class">model.lLike</name> to <name
        type="class">model.global.edit</name>, it was not actually
        done, so did so now.
      </change>
      <change n="5.9.0" who="#sb" when="2016-09-16">
        Incorporate <name type="file">shyTest.sch</name> herein. See
        the description of <ident>shyTests</ident> for limitations.
        Also move some of the Schematron hacks out of declaration for
        <gi>TEI</gi> into the Schematron hack section.
      </change>
      <change n="5.8.0" who="#sb" when="2016-09-15">
        Allow for use an XInclude of the edition statement instead of
        an actual edition statement. Also comment out
        <gi>datatype</gi> in <gi>content</gi> of definition of our
        <gi>format</gi> element, so as to avoid a RELAX NG error
        caused by what I think is a minor bug in TEI stylesheets.
      </change>
      <change n="5.7.2" who="#sb" when="2016-09-14T23:30:00">
        <list>
          <item>Add warning iff no <gi>listPrefixDef</gi></item>
          <item>Allow <gi>listPrefixDef</gi> and <gi>prefixDef</gi> by
          adding them to <att>include</att> of <name
          type="module">header</name> <gi>moduleRef</gi>.</item>
          <item>Allow <gi>code</gi> by adding it to <att>include</att> of <name
          type="module">tagdocs</name> <gi>moduleRef</gi>.</item>
          <item>Add new values <val>file</val>, <val>class</val>,
          <val>macro</val>, and <val>constraint</val> to
          <att>type</att> of <gi>name</gi>.</item>
        </list>
      </change>
      <change n="5.6.1" who="#sb" when="2016-09-14T15:00:00">
        Add <gi>table</gi> to list of elements that will satisfy a <gi>div</gi>
      </change>
      <change n="5.5.1" who="#sb" when="2016-09-01">
        Add missing constraint to warn if a <att>next</att> or
        <att>prev</att> points to itself. Also fix bug in how local
        pointers were checked in same rule.
      </change>
      <change n="5.5.0" who="#sb" when="2016-08-27">
        Change the content model of <gi>floatingText</gi> to match
        that of <gi>text</gi>; also requre <att>xml:id</att> of
        <gi>floatingText</gi>.
      </change>
      <change n="5.4.1" who="#sb" when="2016-08-27">
        <list>
          <item>Bug fix: repair the
          <name>persName-refers-to-person</name>
          <gi>constraintSpec</gi> so that it works with new prefix of
          <code>p:</code> (rather than specifying the partial URL
          <code>personography.xml#</code>).</item>
          <item>Hack to get around TEI bug: change content of
          <gi>format</gi> to RELAX NG, as the TEI stylesheets fail to
          process <gi>valList</gi> properly. (See <ref
          target="https://github.com/TEIC/Stylesheets/issues/154">ticket</ref>.</item>
        </list>
      </change>
      <change n="5.4.0" who="#sb" when="2016-08-24">
        <list>
          <item>Per encoding meeting, add <val>properAdjective</val>
          to value list of <att>type</att> of <gi>name</gi> and
          <gi>placeName</gi></item>
          <item>Per tactical meeting, add <att>gender</att> to
          <gi>role</gi></item>
        </list>
      </change>
      <change n="5.3.0" who="#sb" when="2016-08-10">
        Per Sarah, change list of values of <att>type</att> of <name
        type="class">att.structuralCategorization</name>, including
        those that are not suppposed to be used for <gi>text</gi> and
        now for <gi>body</gi>.
      </change>
      <change n="5.2.1" who="#sb" when="2016-07-06">
        Add <gi>elision</gi> to <name
        type="class">att.dimensions</name>, and move it to <name
        type="class">model.global.edit</name> per discussion at
        encoding meeting.
      </change>
      <change n="5.1.1" who="#sb" when="2016-06-08">
        Revert content model of <gi>vuji</gi> back to impure ODD, as
        pure ODD doesn't work yet (see <ref
        target="https://github.com/TEIC/Stylesheets/issues/154">Stylesheets/
        ticket 154</ref>). Also: mostly cosmetic whitespace fixes, but
        also add a few missing <att>ident</att>s and improve the test
        of TR numbers. This should validate the exact same set of
        files as 5.0.0.
      </change>
      <change n="5.1.0" who="#sb" when="2016-06-02">
        Allow <gi>docRole</gi> inside <gi>imprimatur</gi>
      </change>
      <change n="5.0.0" who="#sb" when="2016-04-30">
        Completed conversion to Pure ODD (which I had begun on or
        about 2016-04-26). RELAX NG only appears in the specifications
        of two macros: <name type="macro">AnyThing</name> and <name
        type="macro">macro.anyXML</name>.
      </change>
      <change n="4.19.2" who="#sb" when="2016-04-21">
        Add test that URL (on an <gi>idno</gi> in the publication statement) looks reasonable.
        (Since this is <soCalled>only</soCalled> a Schematron test, I did not up the minor
        version number, but maybe I should have …)
      </change>
      <change n="4.19.1" who="#sb" when="2016-04-20">
        Add missing namespace prefixes in <ident>something_in_div</ident>.
      </change>
      <change n="4.19.0" who="#sb" when="2016-03-27">
        <list>
          <item>Add Schematron check for <gi>note</gi> elements that
          point to something that does not point back to said same
          <gi>note</gi> via its <att>corresp</att></item>
          <item>Add Schematron check to check that <att>corresp</att>
          doesn't point to the same element it's on</item>
        </list>
      </change>
      <change n="4.18.3" who="#sb" when="2016-03-23">
        Bug fix: content of <gi>gloss</gi> was supposed to be
        <name>model.notePart</name> <emph>plus</emph> the pre-existing
        <name>macro.phraseSeq</name>. However, Sarah has decided she'd
        prefer a more constrained content model, so now we have just
        <name>macro.phraseSeq</name> <emph>plus</emph> <gi>quote</gi>,
        with the expectation that we may need to add a few more as time
        goes on.
      </change>
      <change n="4.18.0" who="#sb" when="2016-03-02">
        Add Schematron check to prevent <code>speaker/persName</code>
        and <code>speaker/choice/abbr</code>.
      </change>
      <change n="4.17.1" who="#sb" notBefore="2016-02-24" notAfter="2016-03-01">
        Typo fix; add descriptions to values of <att>type</att> of <gi>note</gi>
      </change>
      <change n="4.17.0" who="#sb" when="2016-02-24">
        <list>
          <item>Per last week's encoding meeting, made content model
          of <gi>gloss</gi> much looser: <name>model.notePart</name></item>
          <item>put <gi>body</gi> into <name>att.structuralCategorization</name></item>
        </list>
      </change>
      <change n="4.16.0" who="#sb" when="2016-01-14">
        <list>
          <item>Add controlled value list to <att>type</att> of <gi>list</gi> (using
          as values those Sarah found to be in the textbase :-)</item>
          <item>Allow <gi>titleBlock</gi> as child of <gi>back</gi> after <gi>trailer</gi>
          for <name type="file">smith.conversations.xml</name>.</item>
          <item>Copy definition for <val>colophon</val> as a
          <att>type</att> of <gi>div</gi> to the <att>type</att> of
          <gi>titleBlock</gi>, too.</item>
        </list>
      </change>
      <change n="4.15.4" who="#sb" when="2016-01-07">
        Add documntation for values of <att>type</att> of <gi>titleBlock</gi>
      </change>
      <change n="4.15.1" who="#sb" when="2016-01-07">
        Add documntation for values of <att>type</att> of <gi>mw</gi>
      </change>
      <change n="4.15.0" who="#sb" when="2016-01-07">
        Remove <att>when</att> from <gi>time</gi>
      </change>
      <change n="4.14.0" who="#sb" when="2015-11-24">
        Remove all attributes from <gi>tagUsage</gi> except the
        two we actually use (<att>gi</att> and <att>render</att>).
      </change>
      <change n="4.13.1" who="#sb" when="2015-11-24">
        Bug fixes:
        <list>
          <item>was testing <att>xpointer</att> equal to, rather than
          contains, <att>xml:id</att>s of included sections</item>
          <item>had wrong prefix (<q>tei:</q> instead of <q>TEI:</q>) on
          the test that <att>ref</att> of <gi>persName</gi> points to a
          <gi>person</gi>. We use <q>TEI:</q> because we change all
          occurrences of <q>tei:</q> to <q>wwp:</q> in our ISO
          Schematron file before using it. Why? Because
          <name>probatron</name> fails if two <gi>sch:ns</gi>
          declarations have the same value of <att>uri</att>, which is
          ridiculous, but there you have it.</item>
        </list>
      </change>
      <change n="4.13.0" who="#sb" when="2015-11-23">
        <p>Add Schematron constraint to check that <att>ref</att> of
        <gi>persName</gi> points to a <gi>person</gi>. This is pretty
        easy to do when you are assured that there is only 1 pointer
        per <att>ref</att>.
        <egXML xmlns="http://www.tei-c.org/ns/Examples">
          <rule context="wwp:persName[@ref]">
            <let name="file" value="substring-before(.,'#')"/>
            <let name="idrf" value="substring-after(.,'#')"/>
            <!-- We'd like to use a relative path, e.g. concat('../../texts/',$file), -->
            <!-- but then it fails from the commandline (I presume because the base   -->
            <!-- node is taken from a temporary file, not the actual input, but that  -->
            <!-- is just a guess.) -->
            <let name="path" value="concat('https://www.wwp-test.neu.edu/wwo/texts/',$file)"/>
            <let name="docu" value="document( $path, . )"/>
            <let name="seek" value="$docu//TEI:*[@xml:id eq $idrf]"/>
            <assert test="$seek[self::TEI:person]">The @ref of ＜persName＞ should point to a ＜person＞; this one (<value-of select="."/>) points to <value-of select="
            if ($seek) then concat('a ＜', name($seek),'＞') else 'nothing'
            "/>.</assert>
          </rule>
        </egXML>
        However, it is quite a bit harder to do (and perhaps inefficient
        and slow, depending mostly on the optimizers) when there may be
        more than 1 pointer per <att>ref</att>, which is our case.</p>
        <p>I also want to have a drop-down list of values for encoders to
        choose from when entering an <att>ref</att> from within oXygen,
        but that may take a bit of time, as an entire framework has to be
        built (and then managed) to maintain it.</p>
        <p>Note that because we already use <code>tei:</code> as a prefix
        for the WWP namespace, I have used <code>TEI:</code> as the prefix
        for the actual TEI namespace.</p>
      </change>
      <change n="4.12.0" who="#sb" when="2015-11-20">
        <list>
          <item>add <val>docAuthorization</val> to controlled
          vocabulary for <att>type</att> of <gi>div</gi> et. al.</item>
          <item>add <gi>docAuthorization</gi> element; needs more doc</item>
          <item>add <val>docAuthorization</val> and <val>elision</val> to list
          of values allowed as content of <gi>gi</gi></item>
          <item>add <gi>imprimatur</gi> to <name type="class">model.frontPart</name></item>
        </list>
      </change>
      <change n="4.11.2" who="#sb" when="2015-11-18">
        fix date in <gi>change</gi> for 4.11.0
      </change>
      <change n="4.11.1" who="#sconnell.yuw" when="2015-10-08">Per encoding meeting,
        add closed value list for <att>type</att> of <gi>link</gi>.</change>
      <change n="4.11.0" who="#sb" when="2015-10-07"> <!-- note: date of check-in -->
        <list>
          <item>Add <gi>altGrp</gi> to content of <gi>hyperDiv</gi>.</item>
          <item>Remove <gi>linkGrp</gi> and <gi>altGrp</gi> from <name>model.global.meta</name>.</item>
          <item>Remove <gi>linkGrp</gi> and <gi>altGrp</gi> from list of elements that can satisfy content of <gi>div</gi>.</item>
          <item>Add <gi>elision</gi> to list of elements that can satisfy content of <gi>div</gi>.</item>
        </list>
      </change>
      <change n="4.10.1" who="#sb" when="2015-10-04">
        Update version number as schemas are being re-built to use
        (pre-release) fixed version of TEI in which
        <name>macro.paraContent</name> uses <name>model.lLike</name>
        instead of <gi>l</gi> directly.</change>
      <change n="4.10.0" who="#sb" when="2015-09-16">Per
      encoding meeting, change content of <gi>elision</gi> to just
      text and milestones.</change>
      <change n="4.9.0" who="#sb" when="2015-09-02">
        <list>
          <item>Update to match new XInclude of boilerplate metadata system</item>
          <item>Bug fix: Schematron test for <gi>list</gi> was missing namespace prefix</item>
          <item>Add comments about where <name>Probatron</name> chokes on our Schematron. Can't add <gi>desc</gi>, as TEI generates invalid Schematron from it.</item>
        </list>
      </change>
      <change n="4.8.0" who="#sb" when="2015-08-21">
        Bug fix: constrain content of <gi>vuji</gi>
      </change>
      <change n="4.7.0" who="#sb" when="2015-07-24">
        Alter our <gi>g</gi> element: must be empty, <att>ref</att> is
        required, check that <att>ref</att> points to a <gi>char</gi>.
      </change>
      <change n="4.6.2" who="#sb" when="2015-07-22">
        Add <val>goTo</val> to list of possible values of
        <att>type</att> of <gi>ref</gi>
      </change>
      <change n="4.6.1" who="#sb" when="2015-07-20">
        Fix a typo Sarah C. noticed.
      </change>
      <change n="4.6.0" who="#sb" when="2015-07-01">
        Per discussion with Ashley and Sarah change <att>type</att> of
        <gi>stage</gi> to a new <att>kind</att> attribute; the difference
        being that <att>kind</att> can have more than one value. Also add
        three new values to list of possible values, namely
        <val>present</val>, <val>prop</val>, and <val>remains</val>;
        and removed the value <val>mixed</val>.
      </change>
      <change n="4.5.1" who="#sb" when="2015-05-05">
        Per discussion with Ashley and Sarah make <att>type</att> of
        <gi>stage</gi> required, and give it an <val>UNKNOWN</val>
        value as a temporary <soCalled>escape hatch</soCalled> for
        encoders.</change>
      <change n="4.5.0" who="#sb" when="2015-04-30">
        Add Schematron check to <name type="class">att.global.linking</name> that checks that
        <att>next</att> and <att>prev</att> are reasonable:
        <list>
          <item>only 1 URI (i.e., no internal whitespace)</item>
          <item>point to an element in current document</item>
          <item>point to an element w/ same GI</item>
          <item><att>next</att> points to an element after,
          <att>prev</att> to one before, current element</item>
        </list>
      </change>
      <change n="4.4.0" who="#sb" when="2015-01-22">
        Added <att>type</att> of either <val>paraphrase</val> or
        <val>parody</val> to <gi>quote</gi> per today's meeting of WWP
        staff. Also changed content model of <gi>quote</gi> to be
        expressed in <soCalled>pure ODD</soCalled> while there.
      </change>
      <change n="4.3.0" who="#sb" when="2014-12-21">
        Added Schematron check for a note that points to itself.
      </change>
      <change n="4.2.5" who="#sb" when="2014-11-24">
        Added Jesuit Krauss McCormick Library per Sarah Connell.
      </change>
      <change n="4.2.4" who="#sb" when="2014-09-04">
        <list>
          <item>factor out <att>type</att> (and <att>subtype</att>,
          because it wouldn't work with just <att>type</att> alone
          — a bug, I suspect) from <gi>div</gi> into a class of
          its own, and add <gi>div</gi>, <gi>text</gi>, and
          <gi>floatingText</gi> to it. Then add a schematron warning
          if certain values are used on <gi>text</gi>, per Sarah
          Connell.</item>
          <item>add <val>meditation</val> to list of values of
          <att>type</att> of said new class, per last week's encoding
          meeting (the theory being not sure it's a good idea, but
          it's easier to lump it back later than to split them
          apart).</item>
        </list>
      </change>
      <change n="4.2.3" who="#sb" when="2014-09-02">
        Change Hindle and Thomason library key values per Sarah Connell.
      </change>
      <change n="4.2.2" who="#sb" when="2014-08-28">
        Update to match TEI's new content model for <gi>publicationStmt</gi>
      </change>
      <change n="4.2.1" who="#sb" when="2014-02-28">
        Added descriptions to <att>desc</att> and <att>reason</att> of
        <gi>gap</gi> by copying from
        http://librarystaff.neu.edu/svn/DSG/wwp/website/trunk/research/publications/documentation/internal/xml/gap_element.xml#24152 (same as r10492, I think)
        using
        svn://bauman.zapto.org/syd/trunk/Documents/WWP/documentationList2valList.xslt#1885
      </change>
      <change n="4.2.0" who="#sb" when="2014-02-09">
        Reflect move from Brown to Northeastern
      </change>
      <change n="4.1.0" who="#sb" when="2013-02-23">
        Switch from deleting specific elements (using <tag>elementSpec
        mode="delete"</tag>) to including just those we want (using
        <att>include</att> of <gi>moduleRef</gi>) <note>copy of
        ../development-schema/wwp-store.odd#11159</note>
      </change>
      <change n="4.0.2" who="#sb" when="2013-02-20">
        Remove Schematron 1.6 constraints (we're going to use only ISO
        Schematron), and fix the ISO Schematron code so we don't get
        any XPath errors when we try to run it
      </change>
      <change n="4.0.1" who="#sb" when="2013-02-20">
        Bring this change log up-to-date
      </change>
      <change n="4.0.0" who="#sb" when="2013-02-19">
        bring up to P5 v. 2.3.0 (2013-01-17) as I try to fix
        Schematron problem ... fix most of that, too (needed
        <gi>isosch:ns</gi> elements again)
      </change>
      <change n="3.3.2" who="#sb" when="2013-02-08">
        <list>
          <item>add <val>properAdjective</val> to value list of
          <att>type</att> of <gi>rs</gi> (why wasn't it already
          there?)</item>
          <item>Correct library codes per e-mail from Julia <date when="2012-02-07T16:34:44-05:00"/>, <title>library keys
          update</title></item>
        </list>
      </change>
      <change n="3.3.1" who="#sb" when="2013-02-06">
        <list>
          <item>improve definition of <att>type</att> of
          <gi>idno</gi></item>
          <item>add <val>border-ornament</val> and
          <val>border-rule</val> to closed value list for
          <att>type</att> of <gi>mw</gi></item>
        </list>
      </change>
      <change n="3.2.0" who="#sb" when="2013-02-05">
        <list>
          <item>Add an att.global I missed last time</item>
          <item>Finalize closed value list for both <att>type</att>
          and <att>subtype</att> of <gi>lg</gi> (started
          previously)</item>
          <item>Add closed value list for <att>gi</att> of
          <gi>tagUsage</gi> (this list will need to be updated —
          currently by hand — when the list of available elements
          changes)</item>
        </list>
      </change>
      <change n="3.1.6" who="#sb" when="2013-02-04">
        <list>
          <item>Non-working version because value list for
          <att>type</att> of <gi>lg</gi> not finished (see next
          change, chronologically)</item>
          <item>Made valid against current
          https://svn.brown.edu/svn/stg/wwp/website/trunk/outreach/seminars/_current/handouts/TEI_exercise/schemas/brown_odds.rnc,
          mostly by closing enumerated value lists, but also by adding
          many <att>mode</att> to <gi>classes</gi>.</item>
          <item>add att.global to replaced classes, because (as of
          long ago) TEI no longer adds it automagically.</item>
        </list>
      </change>
      <change n="3.1.5" who="#sb" when="2012-03-02">
        Limit value of <gi>gi</gi> to one of our elements
      </change>
      <change n="3.1.4" who="#sb" when="2012-02-26">
        Add constraint to limit <gi>tagUsage</gi> to only 1 per <att>gi</att>
      </change>
      <change n="3.1.2" who="#sb" when="2010-07-14">
        Revert change made at 3.1.1 (i.e., put <att>xml:id</att> back
        to an ID), and instead disallow the <att>xml:id</att>
        attribute within <name type="macro">macro.anyXML</name> (which
        currently is only used by <gi>unknown</gi>, which itself is
        not used much, so this seems like a reasonable way to avoid
        this problem).
      </change>
      <change n="3.1.1" who="#sb" when="2010-07-06">
        Change definition of <att>xml:id</att> from ID to data.name to
        avoid the dreaded <soCalled>problem</soCalled> that <name type="cmd">jing</name> has when it hits <name type="macro">macro.anyXML</name>. (See, e.g., the
        <title>Getting jing to validate xsd:ID typed
        attributes</title> thread on <name>rng-users</name> started
        <date when="2010-07-04T03:20:00"/>; <name type="cmd">jing</name> is probably being technically correct,
        but it is <emph>really</emph> annoying, and as far as I care,
        useless). This means <name type="application">oXygen</name>
        won't be able to do ID/IDREF checking.
      </change>
      <change n="3.1.0" who="#sb" when="2010-06-25">
        <list>
          <item>Add <att>xml:base</att>, as XInclude needs it</item>
          <item>close value list of <att>type</att> of <gi>div</gi> (why didn't we do this years ago?)</item>
        </list>
      </change>
      <change n="3.0.2" who="#sb" when="2010-01-31">
        Use Subversion <code>Id</code> property as <gi>edition</gi>;
        not really right, but TEI doesn't have a good place for
        version information.
      </change>
      <change n="3.0.2" who="#sb" when="2010-01-30">
        <list>
          <item>cheat: permit <gi scheme="xi">xi:include</gi> element child in
          places where we use it in header so that we can do
          pre-XInclude validation in Emacs (if we did post-XInclude
          validation, as we really should, we would not be able to get
          proper line numbers on the errors).</item>
          <item>reflect this same hack in the Schematron, too, as we're
          using NVDL to validate against both RELAX NG and Schematron
          (1.5) schemas in one shot. If we were using separate commands
          (which we may soon), we could just do XInclude processing
          before Schematron validation and not worry, as Schematron
          doesn't give us line numbers anyway.</item>
          <item>use both ISO Schematron and Schematron 1.5 for every
          extra-RELAX constraint (I intend to remove 1.5 if and when
          jing supports ISO Schematron or there is some other handy
          way to perform NVDL validation including RELAX NG and ISO
          Schematron)</item>
        </list>
      </change>
      <change n="3.0.0" who="#sb" when="2010-01-14">
        Add <gi>linkGrp</gi> to content of <gi>hyperDiv</gi>.
      </change>
      <change who="#sb" when="2009-03-02">
        Deleted our <gi>elementSpec</gi> for <gi>tag</gi>, as what we
        were doing was adding <att>type</att>, which P5 now has.
      </change>
      <change who="#sb" when="2008-08-01">
        Initially created from EMPB.
      </change>
    </revisionDesc>
  </teiHeader>
  <text>
    <front>
      <divGen type="toc"/>
    </front>
    <body>
      <p><emph>WARNING</emph>: This is an in-development working system, and as such may at times be broken.</p>
      <p><emph>WARNING</emph>: Current processors probably cannot
      generate valid DTDs (and perhaps not even XSDs) from this ODD.</p>
      <schemaSpec ident="wwp-store" xml:lang="en" prefix="ws_"
                  ns="http://www.wwp.northeastern.edu/ns/textbase"

          start="teiCorpus TEI text body div"> <!--        source="tei:current"-->
        <desc>Women Writers Project storage schema — main schema used
        for data capture and storage of WWO textbase.</desc>
        <!-- ******************************************************** -->
        <!-- element & module inclusion, and element deletion section -->
        <!-- ******************************************************** -->
        <moduleRef key="tei"/>
        <moduleRef key="core" include="abbr add addrLine address analytic author bibl
                                       biblScope biblStruct cb choice citedRange corr date
                                       del desc distinct editor email emph expan foreign gap
                                       gloss graphic head headItem headLabel hi imprint item
                                       l label lb lg list listBibl measure
                                       mentioned milestone monogr name note num orig p pb
                                       ptr pubPlace publisher q quote ref reg resp respStmt
                                       rs said series sic soCalled sp speaker stage
                                       teiCorpus term time title unclear"/>
        <moduleRef key="drama" include="actor castGroup castItem castList role
                                        roleDesc set spGrp"/>
        <moduleRef key="figures" include="figDesc figure table row cell"/>
        <moduleRef key="gaiji" include="char charDecl g mapping"/>
        <moduleRef key="header" include="availability calendarDesc
                                         calendar catDesc catRef category change classDecl
                                         correction edition editionStmt editorialDecl
                                         encodingDesc extent fileDesc funder handNote
                                         hyphenation idno langUsage language licence
                                         listPrefixDef normalization notesStmt prefixDef
                                         profileDesc projectDesc publicationStmt quotation
                                         rendition revisionDesc samplingDecl sourceDesc
                                         sponsor tagsDecl taxonomy teiHeader textClass
                                         titleStmt"/>
        <moduleRef key="linking" include="ab alt altGrp anchor
                                          link linkGrp seg"/>
        <moduleRef key="msdescription" include="dimensions height width"/>
        <moduleRef key="namesdates" include="orgName persName placeName"/>
        <moduleRef key="tagdocs" include="att code gi ident tag val"/>
        <moduleRef key="textstructure" include="TEI argument back body byline closer dateline
                                                div docAuthor docDate docEdition docImprint
                                                epigraph floatingText front group imprimatur
                                                opener postscript salute signed text titlePage
                                                titlePart trailer"/>
        <moduleRef key="transcr" include="addSpan am damageSpan delSpan ex fw handNotes
                                          handShift line listTranspose metamark mod redo
                                          space subst substJoin supplied surplus transpose
                                          undo"/>

        <!-- *************************** -->
        <!-- ODD/Schematron hack section -->
        <!-- *************************** -->
        <constraintSpec scheme="schematron" ident="hack">
          <constraint>
            <sch:ns prefix="TEI" uri="http://www.tei-c.org/ns/1.0"/>
            <sch:ns prefix="tei" uri="http://www.wwp.northeastern.edu/ns/textbase"/>
            <sch:ns prefix="wwp" uri="http://www.wwp.northeastern.edu/ns/textbase"/>
            <sch:ns prefix="xi"  uri="http://www.w3.org/2001/XInclude"/>
          </constraint>
        </constraintSpec>

        <!-- ******************************* -->
        <!-- global Schematron rules section -->
        <!-- ******************************* -->
        <constraintSpec scheme="schematron" ident="rendLadder_keyword_checking">
          <constraint>
            <sch:pattern id="LessThan3InitialCharsDropped">
              <sch:rule context="*[ matches( @rend,'class\s*\(#DIC\)') ]">
                <sch:let name="len"
                         value="if ( .//wwp:sic | .//wwp:corr )
                                then max((
                                  string-length( string-join(.//wwp:sic/normalize-space(), '') ),
                                  string-length(string-join( .//wwp:corr/normalize-space(), ''))
                                  ))
                                else string-length( normalize-space(.) )"/>
                <sch:assert test="$len lt 3">
                  A dropped initial capital is typically only 1 or at
                  most 2 characters long; this one is <sch:value-of
                  select="$len"/> characters long.
                </sch:assert>
              </sch:rule>
            </sch:pattern>
            <sch:pattern id="concrete_rend_keyword_checker"
                         is-a="abstract_rendition_keyword_checker">
              <sch:param name="rendLadderContext" value="wwp:rendition"/>
            </sch:pattern>
            <sch:pattern id="concrete_rendition_keyword_checker"
                         is-a="abstract_rendition_keyword_checker">
              <sch:param name="rendLadderContext" value="wwp:*/@rend"/>
            </sch:pattern>
            <sch:pattern id="abstract_rendition_keyword_checker" abstract="true">
              <sch:rule context="$rendLadderContext">
                <!-- parameter "rendLadderContext" is either "@rend" or "wwp:rendition" -->
                <!-- parameter "me" is the rendition ladder to be checked, with
                     spaces normalized to make it easier to analyze value -->
                <sch:let name="me" value="normalize-space(.)"/>
                <sch:let name="myself" value="replace( replace( $me, ' ?\) ?',')'), ' ?\( ?','(')"/>
                <!-- protect escaped parens by changing to something we won't recognize as a paren -->
                <sch:let name="I" value="replace( replace( $myself,'\\\)','⸩'), '\\\(','⸨')"/>
                <!-- nuke bestow() and bequeath() because they are just too hard -->
                <!-- the royal "we" are not in the mood to give anything away -->
                <sch:let name="we"
                         value="replace( $I,
                                        'be(stow|queath)
                                        \(
                                          \(([a-z-]+\([^)]*\))+\)
                                          \(([A-Za-z][A-Za-z0-9._-]*[ ]?)+\)
                                        \)',
                                        '','x')"/>
                <!-- tokenize on the parenthized arguments, thus nuking them and
                     leaving us with a sequence of keywords -->
                <sch:let name="us" value="tokenize( $we, '\([^)]*\)')"/>
                <!-- test that each keyword is among the ones we allow;
                     1st comparison is for those listed in internal documentation,
                     2nd is for those that I think are correct anyway (and null) -->
                <sch:assert
                    test="every $ego in $us satisfies ( 
                            $ego = ('align', 'bestow', 'border', 'braced', 'bracing', 'break', 'case', 'columns', 'face', 'fill', 'first-indent', 'indent', 'place', 'pos', 'post', 'pre', 'rotate', 'slant', 'space-above', 'sub', 'sup', 'underline', 'underscore')
                            or
                            $ego = ('', 'class', 'inverted', 'myAnchor', 'right-indent', 'rotate', 'rotate-y')
                            )">
                  I parsed the <sch:value-of select="if (self::wwp:rendition) then concat('content of ＜rendition＞ #', (@xml:id,count( preceding::wwp:rendition)+1)[1]) else concat('@rend of a ＜', local-name(..),'＞' )"/>,
                  "<sch:value-of select="."/>", into the keywords "<sch:value-of select="for $ego in ($us) return concat('{',$ego,'}')"/>",
                  at least one of which is not a proper keyword.
                </sch:assert>
              </sch:rule>
            </sch:pattern>
          </constraint>
        </constraintSpec>
        
        <constraintSpec scheme="schematron" ident="TR_and_OT_nums">
          <constraint>
            <sch:let name="hdr" value="substring-before( normalize-space( /wwp:TEI/wwp:teiHeader/@xml:id ),'.hdr')"/>
            <sch:let name="idno" value="normalize-space( /wwp:TEI/wwp:teiHeader/wwp:fileDesc/wwp:publicationStmt/wwp:idno[@type eq 'WWP'] )"/>
            <sch:let name="textID" value="normalize-space( /wwp:TEI/wwp:text/@xml:id )"/>
            <!-- Finding the proper <sourceDesc> is a bit of a pain -->
            <sch:let name="sourceDescs" value="/wwp:TEI/wwp:teiHeader/wwp:fileDesc/wwp:sourceDesc"/>
            <!--
                If there is only one, use it. If there is more than
                one, then *by definition* all but one of them should
                have default=false specified. So ignore all those with
                default=false, and take the other one. (It may or may
                not have default=true. The _Guidelines_ are not
                entirely clear as to whether the default=true has to
                be in the instance or can be grabbed via the default
                value of @default, so I am allowing for either
                possibility here. See P5 15.3.2 "Declarable
                Elements".)
            -->
            <sch:let name="sourceDesc" value="
              if ( count( $sourceDescs ) eq 1 )
                then $sourceDescs
                else $sourceDescs[ not( @default eq 'false') ]
                "/>
            <sch:let name="source" value="normalize-space( $sourceDesc/@n )"/>
            <sch:assert test="matches( $hdr,   '^TR[0-9]{5}(\.[0-9]{2})?$')">TEI Header ID is not in correct format</sch:assert>
            <sch:assert test="matches( $idno,  '^TR[0-9]{5}(\.[0-9]{2})?$')">WWP idno is not in correct format</sch:assert>
            <sch:assert test="matches( $textID,'^TR[0-9]{5}(\.[0-9]{2})?$')"><att>xml:id</att> of <gi>text</gi> is not a proper TR number</sch:assert>
            <sch:assert test="matches( $source,'^OT[0-9]{5}(\.[0-9]{2})?$')"><att>n</att> of <gi>sourceDesc</gi> is not a proper OT number</sch:assert>
            <sch:assert test="$idno eq $textID
                              and
                              substring( $idno, 3 ) eq substring( $source, 3 )
                              and
                              $idno eq $hdr">TR and OT numbers do not all match.</sch:assert>
          </constraint>
        </constraintSpec>

        <constraintSpec scheme="schematron" ident="filenames_match">
          <constraint>
            <sch:let name="myfn" value="tokenize( document-uri(/),'/')[last()]"/>
            <sch:let name="mybase" value="substring-before( $myfn, '.xml')"/>
            <sch:let name="URLidno" value="/wwp:TEI/wwp:teiHeader/wwp:fileDesc/wwp:publicationStmt/wwp:idno[@type eq 'URL']"/>
            <sch:let name="URLidnobase" value="substring-before( tokenize( $URLidno,'/')[last()],'.html')"/>
            <sch:let name="svnIDnot" value="exists( /comment()[contains( ., concat('$','Id','$') ) ] )"/>
            <sch:let name="SVN" value="tokenize( normalize-space( /comment()[contains( .,'$Id:') ] ), ' ')"/>
            <sch:let name="SVNfn" value="$SVN[2]"/>
            <sch:let name="SVNbase" value="substring-before( $SVNfn,'.xml')"/>
            <sch:assert test="matches( $URLidno,'^https?://www\.wwp\.northeastern\.edu/texts/[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.html$')">URL idno is not in correct format</sch:assert>
            <!-- using `probatron`, document-uri(/) returns nil; so only test against the -->
            <!-- real filename if we have one to test. -->
            <sch:assert test="if (normalize-space($myfn) eq '') then true() else $URLidnobase eq $mybase">URL idno does not match filename</sch:assert>
            <!-- similarly, if the substituted Subversion 'Id' keyword is not present, don't test against it -->
            <sch:report test="count( $SVN ) eq 0  and  not( $svnIDnot )">Subversion 'Id' keyword comment not found</sch:report>
            <sch:report test="count( $SVN ) eq 0  and  $svnIDnot">Subversion 'Id' keyword has not been substituted</sch:report>
            <sch:assert test="if (normalize-space($myfn) eq '') then true() else $SVNfn eq $myfn">Subversion 'Id' filename does not match actual filename</sch:assert>
            <sch:assert test="$SVNbase eq $URLidnobase">Subversion 'Id' filename does not match URL idno</sch:assert>
          </constraint>
        </constraintSpec>

        <constraintSpec scheme="schematron" ident="corresp-not-point-to-self">
          <constraint>
            <sch:rule context="*[ @corresp ]">
              <sch:let name="ptr2me" value="concat('#', @xml:id )"/>
              <sch:report test="tokenize( normalize-space( @corresp ),' ') = $ptr2me">ERROR: the <sch:value-of select="name()"/> element with id=<sch:value-of select="@xml:id"/> corresponds to itself</sch:report>
            </sch:rule>
          </constraint>
        </constraintSpec>
        <constraintSpec scheme="schematron" ident="shyTests">
          <desc>Reminder: the resulting tests will <emph>never</emph>
          fire when used with <name type="cmd">probatron</name> or
          other use of the reference implimentation <name
          type="file">iso_svrl_for_xslt2.xsl</name>, because it
          outputs a <soCalled>continuation</soCalled>
          <gi>apply-templates</gi> that selects only elements, not all
          nodes. However, oXygen does not have this problem, so this
          test does work while editing in oXygen. Note also that if
          there are two soft hyphens on one line both the <q>two
          shy!</q> and <q>non-whitespace after shy!</q> errors
          fire.</desc>
          <constraint>
            <sch:rule context="text()[contains(.,'­')]">
              <sch:let name="len" value="43"/>
              <sch:let name="me" value="normalize-space(.)"/>
              <sch:let name="ellipsis" value="if (string-length($me) > $len) then '…' else ''"/>
              <sch:let name="snippet" value="concat( substring( $me, 1, $len), $ellipsis )"/>
              <sch:report test="matches(.,'­.*­')">“<sch:value-of select="$snippet"/>”: two shy!</sch:report>
              <sch:assert test="matches(.,'­\s*$')">“<sch:value-of select="$snippet"/>”: non-whitespace after shy!</sch:assert>
              <sch:assert test="following::text()">“<sch:value-of select="$snippet"/>”: nothing follows shy!</sch:assert>
            </sch:rule>
          </constraint>
        </constraintSpec>

        <!-- ************************ -->
        <!-- element renaming section -->
        <!-- ************************ -->
        <!-- <byline> -> <respLine> -->
        <!-- Besides being renamed, also add to new class model.noteBottom -->
        <elementSpec module="textstructure" ident="byline" mode="change">
          <altIdent>respLine</altIdent>
          <desc>contains a statement of responsibility given for a
          work on its title page or at the head or end of the
          work.</desc>
          <classes mode="change">
            <memberOf key="model.noteBottom"/>
          </classes>
        </elementSpec>
        <!--
             <fw> -> <mw>; also change type= to a required closed list
             of our values, and add a Schematron constraint against
             encoding delimiters on catchwords (as opposed to just
             typing them into the content).
        -->
        <elementSpec module="transcr" ident="fw" mode="change">
          <altIdent>mw</altIdent>
          <gloss>metawork</gloss>
          <constraintSpec ident="catchword_delimiters_in_content" scheme="schematron">
            <desc xml:id="explain_5.42.1">Note: this ODD file contains a Schematron Quick Fix
            for easy repair of the two likely errors tested for,
            below. However, the <att>regex</att> attribute of
            <gi>sqf:stringReplace</gi> <quote>must meet the
            requirements of the <att>regex</att> attribute of the
            <gi>xsl:analyze-string</gi> element</quote> according to
            <ref
            target="https://github.com/schematron-quickfix/sqf/blob/master/schemas/schematron-quickFix.xsd">the
            schema</ref>. In XSLT 2.0 that attribute has a restriction
            that the regular expression must not be one that matches a
            zero-length string. This restriction was removed in XSLT
            3.0, and thus Saxon le 9.5 enforces this restriction, ge
            9.6 does not. So whether this Quick Fix works or not
            depends on which version of oXygen (and thus which version
            of Saxon) you are running. Since our encoders are
            typically still using an older version of oXygen, this
            Quick Fix has been commented out for now.</desc>
            <constraint>
              <sch:rule context="wwp:mw[@type eq 'catch']">
                <sch:report test="matches(@rend,'pre\([^#)]*\)')"> <!-- sqf:fix="pre-to-content"> -->
                  Generally speaking, delimters in a catchword are encoded as content, not on @rend.
                </sch:report>
                <sch:report test="matches(@rend,'post\([^#)]*\)')"> <!-- sqf:fix="post-to-content"> -->
                  Generally speaking, delimters in a catchword are encoded as content, not on @rend.
                </sch:report>
              </sch:rule>
              <!-- <sqf:fixes> -->
              <!--   <sqf:fix id="pre-to-content"> -->
              <!--     <sqf:description> -->
              <!--       <sqf:title>pre() → 1st of content</sqf:title> -->
              <!--       <sqf:p>Remove the pre(), and put its argument into the content of the &lt;mw> before other content</sqf:p> -->
              <!--     </sqf:description> -->
              <!--     <sch:let name="rend_sans_pre" value="replace( @rend,'pre\([^#)]*\)','')"/> -->
              <!--     <sch:let name="pre_arg" value="replace( @rend,'^.*pre\(([^#)]*)\).*$','$1')"/> -->
              <!--     <sqf:replace node-type="attribute" match="@rend" target="rend" select="$rend_sans_pre"/> -->
              <!--     <sqf:stringReplace match="child::text()" regex="^" select="$pre_arg"/> -->
              <!--   </sqf:fix> -->
              <!--   <sqf:fix id="post-to-content"> -->
              <!--     <sqf:description> -->
              <!--       <sqf:title>post() → last of content</sqf:title> -->
              <!--       <sqf:p>Remove the post(), and put its argument into the content of the &lt;mw> after other content</sqf:p> -->
              <!--     </sqf:description> -->
              <!--     <sch:let name="rend_sans_post" value="replace( @rend,'post\([^#)]*\)','')"/> -->
              <!--     <sch:let name="post_arg" value="replace( @rend,'^.*post\(([^#)]*)\).*$','$1')"/> -->
              <!--     <sqf:replace node-type="attribute" match="@rend" target="rend" select="$rend_sans_post"/> -->
              <!--     <sqf:stringReplace match="child::text()" regex="$" select="$post_arg"/> -->
              <!--   </sqf:fix> -->
              <!-- </sqf:fixes> -->
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" usage="req" mode="replace">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="border">
                  <desc>used to signify that there is border around a page.</desc>
                </valItem>
                <valItem ident="border-rule">
                  <desc>used to signify that there is a border made of ruled lines.</desc>
                </valItem>
                <valItem ident="border-ornamental">
                  <desc>used to signify that there is an ornamental border.</desc>
                </valItem>
                <valItem ident="catch">
                  <gloss>catchword</gloss>
                  <desc>for catch words.</desc>
                </valItem>
                <valItem ident="lineNum">
                  <gloss>line number</gloss>
                  <desc>for printed line numbers (usually in poetry)</desc>
                </valItem>
                <valItem ident="listHead">
                  <gloss>list (or similar) heading</gloss>
                  <desc>for list headings. Often used in tables of contents for the <q>page</q> heading.</desc>
                </valItem>
                <valItem ident="pageNum">
                  <gloss>page number</gloss>
                  <desc>for page numbers.</desc>
                </valItem>
                <valItem ident="pressFig">
                  <gloss>press figure</gloss>
                  <desc>for press figures. These are usually numbers, but are not sequential or regularly printed like signatures.</desc>
                </valItem>
                <valItem ident="sig">
                  <gloss>signature</gloss>
                  <desc>for printed signatures.</desc>
                </valItem>
                <valItem ident="unknown">
                  <desc>for a metawork whose function you do not know.</desc>
                </valItem>
                <valItem ident="vol">
                  <gloss>volume number</gloss>
                  <desc>for printed volume numbers.</desc>
                </valItem>
                <valItem ident="other">
                  <desc>Anything not covered by the above values.</desc>
                </valItem>
              </valList>
              <remarks>
                <p>We use <val>other</val> (among other possibilities)
                for an ornament, decorated tool line, or symbol(s)
                that is not officially a delimiter (and thus there is
                no element on which to put <val>pre()</val> or
                <val>post()</val>) but is used to fill space at the
                bottom of a page so that a <gi>floatingText</gi> or
                similar can start at the top of the next.</p>
              </remarks>
            </attDef>
          </attList>
        </elementSpec>
        <!-- <titlePage> -> <titleBlock>; also make type= required and give it our list of values -->
        <elementSpec module="textstructure" ident="titlePage" mode="change">
          <altIdent>titleBlock</altIdent>
          <gloss>title block</gloss>
          <desc>used to to encode the contents of title pages, acting
          as a container or wrapper for the title page's discrete
          elements.</desc>
          <attList>
            <attDef ident="type" mode="change">
              <desc>classifies the title block.</desc>
              <defaultVal>titlePage</defaultVal>
              <valList type="closed">
                <valItem ident="titlePage">
                  <gloss>title page</gloss>
                  <desc>a page of bibliographic information about the current work</desc>
                </valItem>
                <valItem ident="halfTitle">
                  <gloss>half title</gloss>
                  <desc>half titles, bastard titles, or other pages
                  or portions thereof that contian bibliographic
                  information, but less than the true title
                  page</desc>
                </valItem>
                <valItem ident="captionTitle">
                  <gloss>caption title</gloss>
                  <desc>a short snippet of bibliographic information
                  smaller than a half title</desc>
                </valItem>
                <valItem ident="colophon">
                  <desc>A short inscription, typically at the end of a book or manuscript, containing the title, printer, date and place of printing, etc.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <!-- <docAuthor> -> <docRole>; also add type= -->
        <elementSpec module="textstructure" ident="docAuthor" mode="change">
          <altIdent>docRole</altIdent>
          <gloss>document role</gloss>
          <desc>contains an indication of a person or organization who
          played a significant role in the production of the source
          book, as given on the title page (often but not always
          contained in a byline).</desc>
          <attList>
            <attDef ident="type" mode="add" usage="req">
              <valList type="closed">
                <valItem ident="author">
                  <desc>A person who has written some or all of the main content
                  of the text</desc>
                </valItem>
                <valItem ident="editor">
                  <desc>A person who has edited the text without
                  contributing to its main content (adding annotations
                  or providing other editorial oversight)</desc>
                </valItem>
                <valItem ident="translator">
                  <desc>A person who has translated the main content
                  of the text from one language into another</desc>
                </valItem>
                <valItem ident="publisher">
                  <desc>A person or entity responsible for the
                  publication (i.e. the sponsorship of the production
                  and dissemination) of the work; in some cases this
                  may be the author</desc>
                </valItem>
                <valItem ident="printer">
                  <desc>A person or entity responsible for the
                  physical printing process</desc>
                </valItem>
                <valItem ident="bookseller">
                  <desc>A person or entity responsible for the sale
                  and distribution of the work</desc>
                </valItem>
                <valItem ident="printer-publisher">
                  <desc>A person or entity who undertook both responsibilities or performed both tasks</desc>
                </valItem>
                <valItem ident="licensee">
                  <desc> </desc>
                </valItem>
                <valItem ident="licensor">
                  <desc> </desc>
                </valItem>
                <valItem ident="uncertain">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>

        <!-- ************************ -->
        <!-- element addition section -->
        <!-- ************************ -->
        <elementSpec mode="add" ident="translator">
          <desc versionDate="2021-01-14">contains the name (typically
          encoded in <gi>persName</gi> or <gi>orgName</gi>) of the
          entity that translated the bibliograhic item from one
          natural language to another.</desc>
          <classes>
            <memberOf key="att.global"/>
            <memberOf key="att.naming"/>
            <memberOf key="model.respLike"/>
          </classes>
          <content>
            <macroRef key="macro.phraseSeq"/>
          </content>
          <remarks>
            <p>The WWP <gi>translator</gi> element may be thought of
            as syntactic sugar for either <tag>tei:editor
            role="translator"</tag> or
            <code>&lt;tei:respStmt>&lt;tei:resp>translator&lt;/tei:resp>&lt;!--
            ... -->&lt;/tei:respStmt>&lt;/code>.</code></p>
          </remarks>
        </elementSpec>

        <!-- <docAuthorization> -->
        <elementSpec mode="add" ident="docAuthorization">
          <desc versionDate="2005-01-14" xml:lang="en">contains a
          formal statement authorizing the publication of a work;
          differs from <gi>imprimatur</gi> because FIXME <?wwp FIXME?>.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.titlepagePart"/>
            <memberOf key="model.frontPart"/>
          </classes>
          <content>
            <macroRef key="macro.paraContent"/>
          </content>
          <remarks>
            <p>We have 4 elements for this kind of thing:
            <list>
              <item><gi>imprimatur</gi></item>
              <item><gi>docAuthorization</gi></item>
              <item><tag type="start">div type="imprimatur"</tag></item>
              <item><tag type="start">div type="docAuthorization"</tag></item>
            </list>
            </p>
          </remarks>
        </elementSpec>

        <!-- <elision> -->
        <elementSpec ident="elision" mode="add">
          <desc>marks cases in which material is excerpted in a
          quotation or other textual representation within the source
          text.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="att.typed"/>
            <memberOf key="att.dimensions"/>
            <memberOf key="model.global.edit"/>
          </classes>
          <content>
            <alternate minOccurs="1" maxOccurs="unbounded">
              <classRef key="model.global"/>
              <macroRef key="macro.xtext"/>
            </alternate>
          </content>
          <exemplum>
            <p>I (Syd) <emph>think</emph> this would be how this
            should be used, but I may be mistaken; or we may change
            our minds.</p>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
              <lg>
                <!-- ... -->
                <l>Beneath accumulated horror, ſinks</l>
                <l>The deſolate mourner!</l>
              </lg>
              <elision>
                <lb/>* * * * * * * * * *
                <lb/>* * * * * * * * * *
                <lb/>* * * * * * * * * *
              </elision>
              <lg type="indeterminate">
                <l>The feudal Chief, whoſe <rs type="properAdjective">Gothic</rs> battlements</l>
                <l>Frown on the plain beneath, returning home</l>
                <!-- ... -->
              </lg>
            </egXML>
          </exemplum>
        </elementSpec>
        <!-- <acrostics> and <acrostic> -->
        <elementSpec ident="acrostics" mode="add">
          <desc>Container that occurs in <gi>hyperDiv</gi> and holds
          one or more <gi>acrostic</gi> elements.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.hyperDivPart"/>
          </classes>
          <content>
            <elementRef key="acrostic" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="acrostic" mode="add">
          <desc>a derived element that contains the word or phrase
          (including any appropriate phrase-level encoding like
          <gi>persName</gi>) that are spelled by the initial letters
          of a passage (e.g., the first letter of each lineof a
          stanza or poem).</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
          </classes>
          <content>
            <macroRef key="macro.phraseSeq"/>
          </content>
          <attList>
            <attDef ident="target" usage="req">
              <desc>points to the parent element (e.g., an
              <gi>lg</gi>) that contains the elements of which the
              first letter of each make up the acrostic.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.pointer"/></datatype>
            </attDef>
            <attDef ident="components" usage="opt">
              <desc>Idunno</desc>
              <datatype minOccurs="2" maxOccurs="unbounded"><dataRef key="teidata.pointer"/></datatype>
            </attDef>
          </attList>
        </elementSpec>
        <!-- <anagrams> and <anagram> -->
        <elementSpec ident="anagrams" mode="add">
          <desc>Container that occurs in <gi>hyperDiv</gi> and holds
          one or more <gi>anagram</gi> elements.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.hyperDivPart"/>
          </classes>
          <content>
            <elementRef key="anagram" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <elementSpec ident="anagram" mode="add">
          <desc>points to 2 or more textual elements to indicate they
          are anagrams of each other, OR points to a single textual
          element to indicate said element is an anagram of its content</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="att.pointing"/>
          </classes>
          <content>
            <macroRef key="macro.phraseSeq"/>
          </content>
          <attList>
            <attDef ident="target" usage="req" mode="change">
              <desc>points to an element of which the current element
              is (roughly) an anagram, or points to 2 or more elements
              whose content are (roughly) anagrams of each
              other</desc>
              <datatype minOccurs="1" maxOccurs="unbounded">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <constraintSpec scheme="schematron" ident="one_ptr_iff_content">
                <constraint>
                  <sch:rule context="anagram[normalize-space(.) eq '']">
                    <sch:let name="targets" value="tokenize( normalize-space( @target ),'&#x20;')"/>
                    <sch:assert test="count( $targets ) gt 1">An empty ＜anagram＞ element should point to 2 or more targets</sch:assert>
                  </sch:rule>
                  <sch:rule context="anagram[normalize-space(.) ne '']">
                    <sch:let name="targets" value="tokenize( normalize-space( @target ),'&#x20;')"/>
                    <sch:assert test="count( $targets ) eq 1">An ＜anagram＞ element that contains an anagram should point to only 1 target</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
              <remarks>
                <p>The elements pointed to should be intentional, if
                not exact, anagrams of one another. If one of the
                textual objects that is an anagram is made of several
                XML elements, then the <att>target</att> should point
                to either <emph>the first</emph> XML element (in
                document order) if they are connected with
                <att>part</att> or <att>next</att> &amp;
                <att>prev</att>; or to a <gi>link</gi> or
                <gi>join</gi>. The point is, the <att>target</att>
                should not point to each XML element that is a
                component of a single anagram.</p>
              </remarks>
            </attDef>
          </attList>
          <remarks>
            <p>The <gi>anagram</gi> element may contain content to
            indicate the re-arranged order of the letters in the
            source, for use when the source does not indicate the
            re-arrangement itself. E.g., if the source says <quote>He
            hired a new <soCalled>crap built on lies</soCalled>
            officer</quote>, but does not explain what <quote>crap
            built on lies</quote> is an anagrom <emph>for</emph>, we
            might encode
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
              <anagram target="#cbol">public relations</anagram>
              &lt;!-- ... -->
              <lb/>He hired a new <soCalled xml:id="cbol">crap built
              on lies</soCalled> officer
            </egXML>
            </p>
          </remarks>
        </elementSpec>
        <!-- <adds> -->
        <elementSpec ident="adds" mode="add">
          <desc>Container that occurs in <gi>hyperDiv</gi> and holds
          one or more <gi>add</gi> elements.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.hyperDivPart"/>
          </classes>
          <content>
            <elementRef key="add" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <remarks>
            <p>Currently we only encode an <gi>add</gi> in the
            <gi>hyperDiv</gi> if its content is a note of some
            sort.</p>
          </remarks>
        </elementSpec>
        <!-- <notes> -->
        <elementSpec ident="notes" mode="add">
          <desc>Container that occurs in <gi>hyperDiv</gi> and holds
          one or more <gi>note</gi> elements.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.hyperDivPart"/>
          </classes>
          <content>
            <elementRef key="note" minOccurs="1" maxOccurs="unbounded"/>
          </content>
        </elementSpec>
        <!-- <mcr> -->
        <elementSpec ident="mcr" mode="add">
          <gloss>meaningful change in rendition</gloss>
          <desc>marks a word or phrase as graphically distinct from the
          surrounding text, for reasons concerning which no claim is
          made, other than there is some meaning present.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.hiLike"/>
          </classes>
          <content>
            <macroRef key="macro.paraContent"/>
          </content>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples"><p><mcr>Item</mcr>, 200 Crowns to <persName>Iſabella</persName> for undertaking.</p></egXML>
          </exemplum>
        </elementSpec>
        <!-- <hyperDiv> -->
        <elementSpec ident="hyperDiv" mode="add">
          <gloss>hyper division</gloss>
          <desc>Those things that are part of the textual content of
          the document, or directly related to it, but do not fit into
          the front matter, body, or back matter.</desc>
          <content>
            <classRef key="model.hyperDivPart" expand="sequenceOptional"/>
          </content>
          <constraintSpec scheme="schematron" ident="adds_in_adds_have_note">
            <constraint>
              <sch:rule context="tei:adds/tei:add/child::*">
                <sch:assert test="self::wwp:note">An ＜add＞ inside ＜adds＞ inside the ＜hyperDiv＞ should not have any children other than ＜note＞ (and there is a ＜<sch:name/>＞ here).</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>Currently, the content of the <gi>hyperDiv</gi> is
            quite restrictive. It consists of 0 or 1 of each of the
            following, in the specified order:
            <list>
              <item><gi>castList</gi>, for speaking roles that occur
              in the drama, but for which there is no entry in the
              printed cast list.</item>
              <item><gi>linkGrp</gi>, for <gi>link</gi>s; at the moment we only
              use these for indicating a grouping of disparate elements</item>
              <item><gi>altGrp</gi> for <gi>alt</gi>s; at the moment we only
              use these for indicating an alternation of possible referents (e.g.,
              <q>Green Lantern</q> would be encoded with a <att>ref</att> that points to an <gi>alt</gi>
              that has <code>target="#Guy_Garnder #John_Stewart"</code>).</item>
              <item><gi>acrostics</gi>, for <gi>acrostic</gi>s</item>
              <item><gi>anagrams</gi>, for <gi>anagram</gi>s</item>
              <item><gi>adds</gi>, for additions (encoded with
              <gi>add</gi>) that are the addition of a footnote or
              marginal note (encoded with <gi>note</gi>)</item>
              <item><gi>notes</gi>, for footnotes and marginal notes
              (encoded with <gi>note</gi>)</item>
            </list>
            In the future we may consider loosening or re-arranging this.</p>
          </remarks>
        </elementSpec>
        <!-- <advertisement> -->
        <elementSpec ident="advertisement" mode="add">
          <desc xml:lang="en">A section of text, typically in the
          backmatter, that advertises other books by the same author,
          publisher, bookseller, etc.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.noteLike"/>
          </classes>
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <classRef key="model.common"/>
              <classRef key="model.global"/>
              <classRef key="model.biblPart"/>
            </alternate>
          </content>
          <remarks>
            <p>These are different from the
            <soCalled>advertisements</soCalled> that occur in front
            matter (prefatory materials that resemble introductions).
            The front-matter <soCalled>advertisements</soCalled>
            should be recorded with <tag>div type="prefatory"</tag>.</p>
            <p>The advertisement usually contains a <gi>bibl</gi>
            element, since it often has information about the title
            and author of a book. Note, though, that prose
            descriptions of the texts should not be recorded within
            bibl.</p>
            <p>Many advertisements will contain information about the
            pricing of the texts for sale. These prices should be
            recorded in <gi>measure</gi> if they are renditionally
            distinct. These prices should not, however, be recorded in
            <gi>docSale</gi>, as this element should be used
            exclusively in title pages.</p>
          </remarks>
        </elementSpec>
        <!-- <unknown> -->
        <elementSpec ident="unknown" mode="add">
          <desc xml:lang="en">used to indicate a passage about which the proper
          encoding is not known to the encoder.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.global"/>
            <memberOf key="att.ascribed"/>
            <memberOf key="att.typed"/>
          </classes>
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <macroRef key="macro.anyXML"/>
              <textNode/>
            </alternate>
          </content>
          <attList>
            <attDef ident="desc">
              <datatype minOccurs="1" maxOccurs="unbounded"><dataRef key="teidata.word"/></datatype>
            </attDef>
          </attList>
        </elementSpec>
        <!-- <docSale> -->
        <elementSpec ident="docSale" mode="add">
          <gloss>document sales information</gloss>
          <desc>used to encode commercial transaction infromation
          (e.g., price) as appears in a <gi>titleBlock</gi>.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.titlepagePart"/>
          </classes>
          <content>
            <macroRef key="macro.specialPara"/>
          </content>
        </elementSpec>

        <!-- ******************************** -->
        <!-- class deletion section           -->
        <!-- classes we don't use get deleted -->
        <!-- ******************************** -->
        <classSpec module="tei" ident="att.placement" mode="delete" type="atts"/>
        <classSpec module="tei" ident="att.ranging" mode="delete" type="atts"/>
        <classSpec module="transcr" ident="att.global.facs" mode="delete" type="atts"/>

        <!-- ************************** -->
        <!-- attribute deletion section -->
        <!-- ************************** -->
        <elementSpec module="core" ident="del" mode="change">
          <attList>
            <attDef ident="type" mode="delete"/>
          </attList>
          <remarks>
            <p>At the WWP we do not (currently) use <att>type</att> on
            <gi>del</gi>.</p>
          </remarks>
        </elementSpec>
        <elementSpec module="core" ident="time" mode="change">
          <attList>
            <attDef ident="when" mode="delete"/>
          </attList>
          <remarks>
            <p>At the WWP we use <att>when-iso</att> on <gi>time</gi>,
            not <att>when</att>, because in the vast majority of cases
            we do not have sufficient precision to include seconds
            (which W3C requires).</p>
          </remarks>
        </elementSpec>
        <!-- att.global.linking is handled in attribute constraint section -->
        <!-- cRef= is removed from <ptr> and <ref> in the attribute constraint section -->
        <elementSpec module="core" ident="term" mode="change">
          <attList>
            <attDef ident="target" mode="delete"/>
            <attDef ident="cRef" mode="delete"/>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="gloss" mode="change">
          <content>
            <sequence minOccurs="1" maxOccurs="unbounded">
              <macroRef key="macro.phraseSeq"/>
              <elementRef key="quote" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
          <attList>
            <attDef ident="target" mode="delete"/>
            <attDef ident="cRef" mode="delete"/>
          </attList>
        </elementSpec>
        <classSpec module="tei" type="atts" ident="att.transcriptional" mode="change">
          <attList>
            <attDef mode="delete" ident="status"/>
          </attList>
          <remarks><p>The WWP does not use the TEI transcriptional
          <att>status</att> attribute.</p></remarks>
        </classSpec>

        <!-- ********************** -->
        <!-- class addition section -->
        <!-- ********************** -->
        <classSpec type="atts" ident="att.structuralCategorization" mode="add">
          <desc>provides a <att>type</att> attribute with a closed
          value list suitable for use with structural elements like
          <gi>text</gi>, <gi>floatingText</gi>, and
          <gi>div</gi>.</desc>
          <constraintSpec scheme="schematron" ident="value-of-div-not-text">
            <constraint>
              <sch:rule context="wwp:text">
                <sch:report test="@type = ('act',
                                           'advert',
                                           'argument',
                                           'book',
                                           'calendar',
                                           'castlist',
                                           'chapter',
                                           'colophon',
                                           'concluding',
                                           'confession',
                                           'contents',
                                           'corrigenda',
                                           'ded',
                                           'docAuthorization',
                                           'dramaPart',
                                           'endnotes',
                                           'entry',
                                           'epigraph',
                                           'epilogue',
                                           'frontispiece',
                                           'index',
                                           'imprimatur',
                                           'novelPart',
                                           'placeholder',
                                           'prefatory',
                                           'prologue',
                                           'scene',
                                           'section',
                                           'subsection',
                                           'timeline')">warning: the "<sch:value-of select="@type"/>" value of @type is not intended to be used on ＜text＞.</sch:report>
                </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="value-of-div-not-body">
            <constraint>
              <sch:rule context="wwp:body">
                <sch:report test="@type = ('advert',
                                           'argument',
                                           'book',
                                           'calendar',
                                           'castlist',
                                           'chapter',
                                           'colophon',
                                           'concluding',
                                           'contents',
                                           'corrigenda',
                                           'ded',
                                           'docAuthorization',
                                           'endnotes',
                                           'entry',
                                           'epigraph',
                                           'epilogue',
                                           'frontispiece',
                                           'index',
                                           'imprimatur',
                                           'novel',
                                           'part',
                                           'prefatory',
                                           'prologue',
                                           'scene',
                                           'section',
                                           'subsection',
                                           'timeline',
                                           'volume')">warning: the "<sch:value-of select="@type"/>" value of @type is not intended to be used on ＜body＞.</sch:report>
                </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef mode="add" ident="subtype" usage="opt">
              <desc versionDate="2005-10-10" xml:lang="en">provides a sub-categorization of the element, if needed</desc>
              <datatype><dataRef key="teidata.enumerated"/></datatype>
              <remarks versionDate="2013-01-13" xml:lang="en">
                <p>The <att>subtype</att> attribute may be used to provide any
                sub-classification for the element additional to that provided by its
                <att>type</att> attribute.</p>
              </remarks>
            </attDef>
            <attDef mode="add" ident="type">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="act">
                  <desc>An act in a dramatic text.</desc>
                </valItem>
                <valItem ident="advert">
                  <desc>An advertisement for a printed work or other product.</desc>
                </valItem>
                <valItem ident="argument">
                  <desc>A short passage at the start of a document or section giving a prose description of its contents.</desc>
                </valItem>
                <valItem ident="book">
                  <desc>A major structural component of a long work, identified explicitly in the text as a <soCalled>book</soCalled>.</desc>
                </valItem>
                <valItem ident="calendar">
                  <desc>A formal calendar; a document or document section identifying itself as a calendar</desc>
                </valItem>
                <valItem ident="castlist">
                  <desc>A list of characters in a dramatic text</desc>
                </valItem>
                <valItem ident="chapter">
                  <desc>A chapter, typically in a prose document </desc>
                </valItem>
                <valItem ident="colophon">
                  <desc>A short inscription, typically at the end of a book or manuscript, containing the title, printer, date and place of printing, etc.</desc>
                </valItem>
                <valItem ident="concluding">
                  <desc>Any section of the back matter that does not carry a more specific designation; includes afterwords, epilogues, codas, etc.</desc>
                </valItem>
                <valItem ident="confession">
                  <desc>A section that is identified explicitly as a <soCalled>confession</soCalled> in a text that uses this as a main structural division.</desc>
                </valItem>
                <valItem ident="contents">
                  <desc>A table of contents.</desc>
                </valItem>
                <valItem ident="corrigenda">
                  <desc>A section describing corrections to be made to the document.</desc>
                </valItem>
                <valItem ident="drama">
                  <desc>A dramatic text.</desc>
                </valItem>
                <valItem ident="dramaPart">
                  <desc>A portion of a drama other than a prologue, act, scene, or epilogue.</desc>
                </valItem>
                <valItem ident="ded">
                  <desc>A dedication.</desc>
                </valItem>
                <valItem ident="docAuthorization">
                  <desc>A statement indicating that the document's printing was officially authorized.</desc>
                </valItem>
                <valItem ident="endnotes">
                  <desc>A section containing endnotes for the document.</desc>
                </valItem>
                <valItem ident="entry">
                  <desc>An entry in a document that is organized as a log or diary with dated entries.</desc>
                </valItem>
                <valItem ident="epigraph">
                  <desc>A short quotation at the start of a document or section, often accompanied by an attribution.</desc>
                </valItem>
                <valItem ident="epilogue">
                  <desc>A short concluding section, usually of a dramatic or fictional work.</desc>
                </valItem>
                <valItem ident="essay">
                  <desc>A short prose non-fiction document.</desc>
                </valItem>
                <valItem ident="examination">
                  <desc>A section that is identified explicitly as an <soCalled>examination</soCalled> in a text that uses this as a main structural division.</desc>
                </valItem>
                <valItem ident="frontispiece">
                  <desc>A portrait or other image (usually of the author, usually full page) printed at the front of a document. </desc>
                </valItem>
                <valItem ident="index">
                  <desc>An alphabetical listing of the topics in a document, usually with accompanying page references</desc>
                </valItem>
                <valItem ident="imprimatur">
                  <desc>A formal indication (usually on the title page or in the front matter) that the document has received official license to be printed.</desc>
                </valItem>
                <valItem ident="letter">
                  <desc>Any document in epistolary form, i.e. addressed by a sender to a recipient.</desc>
                </valItem>
                <valItem ident="meditation">
                  <desc>A section that is described explicitly as a <soCalled>meditation</soCalled> in a document that uses this as a main structural division.</desc>
                </valItem>
                <valItem ident="narrative">
                  <desc>An embedded narrative.</desc>
                </valItem>
                <valItem ident="nonfictionProse">
                  <desc>A text intended to be nonfiction consisting primarily of prose.</desc>
                </valItem>
                <valItem ident="novel">
                  <desc>A novel.</desc>
                </valItem>
                <valItem ident="novelPart">
                  <desc>A portion of a novel.</desc>
                </valItem>
                <valItem ident="part">
                  <desc>A major component of a work, containing further subdivisions.</desc>
                </valItem>
                <valItem ident="petition">
                  <desc>A formal plea to an authority.</desc>
                </valItem>
                <valItem ident="placeholder">
                  <desc> </desc>
                </valItem>
                <valItem ident="poem">
                  <desc>A poem.</desc>
                </valItem>
                <valItem ident="poemGroup">
                  <desc>A group of two or more poems under a common heading.</desc>
                </valItem>
                <valItem ident="prayer">
                  <desc>A prayer.</desc>
                </valItem>
                <valItem ident="prefatory">
                  <desc>A section of the front matter that does not carry a more specific designation.</desc>
                </valItem>
                <valItem ident="prologue">
                  <desc>An opening section of a literary work (typically drama or poetry). </desc>
                </valItem>
                <valItem ident="recipe">
                  <desc>A recipe in a cookbook.</desc>
                </valItem>
                <valItem ident="scene">
                  <desc>A scene in a dramatic text </desc>
                </valItem>
                <valItem ident="section">
                  <desc>A generic section of a larger work.</desc>
                </valItem>
                <valItem ident="speech">
                  <desc>A section described as a speech or public lecture, in a document that uses this as a main structural division.</desc>
                </valItem>
                <valItem ident="subsection">
                  <desc>A generic subdivision of a section.</desc>
                </valItem>
                <valItem ident="timeline">
                  <desc>A timeline. </desc>
                </valItem>
                <valItem ident="tract">
                  <desc>A short treatise in pamphlet form often on a religious subject.</desc>
                </valItem>
                <valItem ident="undetermined">
                  <desc>A text component whose genre has not been determined. </desc>
                </valItem>
                <valItem ident="volume">
                  <desc>A single printed volume in a multi-volume work. </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>

        <!-- ****************************************** -->
        <!-- other class and macro manipulation section -->
        <!-- ****************************************** -->
        <dataSpec module="tei" ident="teidata.word" mode="change">
          <!-- Hack around apparent bug in jing: "⸿" should be part of
               \p{P}, as it has Unicode class "punctuation, other",
               but nonetheless jing says it is invalid -->
          <content>
            <dataRef name="token" restriction="(\p{L}|\p{N}|\p{P}|\p{S}|⸿)+"/>
          </content>
        </dataSpec>
        <macroSpec ident="macro.anyXML" module="tei" mode="change">
          <content>
            <rng:element>
              <rng:anyName>
                <rng:except>
                  <rng:nsName ns="http://www.tei-c.org/ns/1.0"/>
                  <rng:name ns="http://www.tei-c.org/ns/Examples">egXML</rng:name>
                </rng:except>
              </rng:anyName>
              <rng:zeroOrMore>
                <rng:attribute>
                  <rng:anyName>
                    <rng:except>
                      <rng:name>xml:id</rng:name>
                    </rng:except>
                  </rng:anyName>
                </rng:attribute>
              </rng:zeroOrMore>
              <rng:zeroOrMore>
                <rng:choice>
                  <rng:text/>
                  <rng:ref name="macro.anyXML"/>
                </rng:choice>
              </rng:zeroOrMore>
            </rng:element>
          </content>
          <remarks>
            <p>At the WWP, the <att>xml:id</att> attribute is not
            permitted in <name type="macro">macro.anyXML</name>. This
            is to prevent the known error reported by <name type="cmd">jing</name> validation. (See, e.g., the
            <title>Getting jing to validate xsd:ID typed
            attributes</title> thread on <name>rng-users</name>
            started <date when="2010-07-04T03:20:00"/>.) Currently
            <name type="macro">macro.anyXML</name> is only used by
            <gi>unknown</gi>, which itself is not used much, so this
            seems like a reasonable way to avoid this problem.</p>
          </remarks>
        </macroSpec>
        <dataSpec ident="wwpdata.sex" mode="add">
          <desc>Possible values to represent sex</desc>
          <content>
            <!-- Use old-fashioned <rng:choice>, because Stylesheets/ code for newer, better <valList> -->
            <!-- does not work, at least for now. See Stylesheets/ ticket #154. -->
            <rng:choice>
              <rng:value>male</rng:value>
              <rng:value>female</rng:value>
              <rng:value>mixed</rng:value>
              <rng:value>unknown</rng:value>
              <rng:value>inapplicable</rng:value>
            </rng:choice>
            <!-- valList type="closed">
              <valItem ident="male"/>
              <valItem ident="female"/>
              <valItem ident="mixed">
                <desc>Not intended for use on <att>sex</att> of <gi>person</gi></desc>
              </valItem>
              <valItem ident="unknown"/>
              <valItem ident="inapplicable"/>
            </valList -->
          </content>
        </dataSpec>
        <classSpec module="core" type="atts" ident="att.global" mode="change">
          <constraintSpec ident="xmlID-is-unique" scheme="schematron">
            <constraint>
              <sch:rule context="@xml:id">
                <sch:let name="thisID" value="normalize-space(.)"/>
                <sch:report test="../(ancestor::*|preceding::*)/@xml:id[ normalize-space(.) eq $thisID ]
                                 ">The @xml:id "<sch:value-of select="$thisID" />" on &lt;<sch:value-of
                                 select="name(..)"/>> duplicates an @xml:id found earlier in the document</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>The WWP does not currently use the XML <att
            scheme="xml">base</att> attribute. It is permitted by this
            schema so that validation post-XInclude processing
            works.</p>
            <p>The <att>rendition</att> attribute is
            currently only used in those cases where a non-Unicode
            character is required in the value of the rendition
            ladder.</p>
          </remarks>
        </classSpec>

        <!-- ************************************************************** -->
        <!-- section for changes to content models of "normal" TEI elements -->
        <!-- ************************************************************** -->
        <elementSpec module="textstructure" ident="TEI" mode="change">
          <content>
            <sequence>
              <elementRef key="teiHeader"/>
              <elementRef key="text"/>
            </sequence>
          </content>
        </elementSpec>

        <elementSpec module="drama" ident="spGrp" mode="change">
          <attList>
            <attDef mode="change" ident="type" usage="req">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="closed">
                <valItem ident="couplet"> <desc/> </valItem>
                <valItem ident="indeterminate"> <desc/> </valItem>
                <valItem ident="octet"> <desc/> </valItem>
                <valItem ident="quatrain"> <desc/> </valItem>
                <valItem ident="quintet"> <desc/> </valItem>
                <valItem ident="refrain"> <desc/> </valItem>
                <valItem ident="septet"> <desc/> </valItem>
                <valItem ident="sestet"> <desc/> </valItem>
                <valItem ident="simultaneous"> <desc/> </valItem>
                <valItem ident="stanza"> <desc/> </valItem>
                <valItem ident="tercet"> <desc/> </valItem>
              </valList>
              <remarks>
                <p>This list is not neccesarily complete. If you find
                something that you do not think fits into any of these
                catagories, use <val>indeterminate</val> and bring it
                up at an encoding meeting. —Syd, 2018-08-13</p>
              </remarks>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="choice" mode="change">
          <content>
            <alternate minOccurs="1" maxOccurs="1">
              <sequence minOccurs="1" maxOccurs="1">
                <elementRef key="sic"/>
                <elementRef key="corr" maxOccurs="unbounded"/>
              </sequence>
              <sequence minOccurs="1" maxOccurs="1">
                <elementRef key="abbr"/>
                <elementRef key="expan" maxOccurs="unbounded"/>
              </sequence>
              <sequence minOccurs="1" maxOccurs="1">
                <elementRef key="orig"/>
                <elementRef key="reg" maxOccurs="unbounded"/>
              </sequence>
              <elementRef key="unclear" minOccurs="2" maxOccurs="unbounded"/>
              <elementRef key="supplied" minOccurs="2" maxOccurs="unbounded"/>
            </alternate>
          </content>
        </elementSpec>
        <elementSpec module="core" ident="hi" mode="change">
          <constraintSpec ident="some_must_have_rend" scheme="schematron">
            <constraint>
              <sch:rule context="tei:hi | tei:mcr | tei:emph">
                <sch:let name="myName" value="local-name(.)"/>
                <sch:let name="myDefaultRendition"
                         value="/tei:TEI/tei:teiHeader/tei:encodingDesc/tei:tagsDecl/tei:rendition[ $myName = tokenize( @selector,'[ ,]+') ]"/>
                <sch:let name="myRealRend" value="concat( $myDefaultRendition, @rend )"/>
                <sch:assert test="contains( $myRealRend, '&#x0028;')">Wha? This <gi><sch:value-of select="$myName"/></gi> element has no (usable) rendition</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <elementSpec module="core" ident="speaker" mode="change">
          <constraintSpec scheme="schematron" ident="no_details_in_speaker">
            <constraint>
              <sch:report test="wwp:persName" role="warning">We do not normally put <gi>persName</gi> inside of a <gi>speaker</gi></sch:report>
              <sch:report test="wwp:choice/wwp:abbr|wwp:abbr|wwp:expan" role="warning">We do not typically record or normalize abbreviations (or expansions) inside of a <gi>speaker</gi></sch:report>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <elementSpec module="textstructure" ident="body" mode="change">
          <classes mode="change">
            <memberOf key="att.structuralCategorization" mode="add"/>
          </classes>
        </elementSpec>
        <elementSpec module="textstructure" ident="back" mode="change">
          <content>
            <sequence>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <classRef key="model.frontPart"/>
                <classRef key="model.pLike.front"/>
                <classRef key="model.pLike"/>
                <classRef key="model.listLike"/>
                <classRef key="model.global"/>
              </alternate>
              <alternate minOccurs="0">
                <sequence>
                  <classRef key="model.div1Like"/>
                  <alternate minOccurs="0" maxOccurs="unbounded">
                    <classRef key="model.frontPart"/>
                    <classRef key="model.div1Like"/>
                    <classRef key="model.global"/>
                  </alternate>
                </sequence>
                <sequence>
                  <classRef key="model.divLike"/>
                  <alternate minOccurs="0" maxOccurs="unbounded">
                    <classRef key="model.frontPart"/>
                    <classRef key="model.divLike"/>
                    <classRef key="model.global"/>
                  </alternate>
                </sequence>
              </alternate>
              <sequence minOccurs="0">
                <classRef key="model.divBottomPart"/>
                <alternate minOccurs="0" maxOccurs="unbounded">
                  <classRef key="model.divBottomPart"/>
                  <elementRef key="titlePage"/>            <!-- added by WWP -->
                  <classRef key="model.global"/>
                </alternate>
              </sequence>
            </sequence>
          </content>
          <remarks>
            <p>At the WWP a <gi>titleBlock</gi> is permitted in the
            content of <gi>back</gi> after a <gi>trailer</gi> (or
            other member of <name type="class">model.divBottomPart</name>).
            This was originally put in to accomodate
            <name type="file">smith.conversations.xml</name>.
            </p>
          </remarks>
        </elementSpec>
        <elementSpec module="header" ident="change" mode="change">
          <attList>
            <attDef ident="when" mode="change" usage="req"/>
            <attDef ident="who" mode="change" usage="req">
              <datatype minOccurs="1" maxOccurs="6">
                <dataRef name="anyURI" restriction="p:[a-z]{2,9}\.[a-z]{3}"/>
              </datatype>
              <remarks>
                <p>At the WWP the <att>who</att> should be expressed as 1–6
                name keys each preceded by the <q>p:</q> prefix.</p>
              </remarks>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="header" ident="classDecl" mode="change">
          <desc xml:lang="en">contains a taxonomy (in a
          <gi>taxonomy</gi>) defining any classificatory codes used
          elsewhere in the text.</desc>
          <content>
            <elementRef key="taxonomy"/>
          </content>
          <remarks><p>The WWP version of this element more restrictive
          than TEI. The TEI allows one or more <gi>taxonomy</gi>
          children, whereas we allow only one.</p></remarks>
        </elementSpec>
        <!-- In <figure>, require <figDesc>, and allow <lg> to be used as a -->
        <!-- caption as well as <p> or <ab>; while we're here, impose -->
        <!-- the order of elements we used in our P4 DTD, mostly -->
        <!-- because we want the <p>, <ab>, and <lg> used for the -->
        <!-- caption to be contiguous -->
        <elementSpec module="figures" ident="figure" mode="change">
          <content>
            <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            <sequence minOccurs="0" maxOccurs="unbounded">
              <elementRef key="head"/>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
            <sequence minOccurs="0" maxOccurs="unbounded">
              <alternate>
                <classRef key="model.pLike"/>
                <elementRef key="lg"/>
              </alternate>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
            <sequence>
              <elementRef key="figDesc"/>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
            <sequence minOccurs="0">
              <elementRef key="floatingText"/>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
            <sequence minOccurs="0" maxOccurs="unbounded">
              <alternate>
                <classRef key="model.pLike"/>
                <elementRef key="lg"/>
              </alternate>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        <!-- <rendition> is the same as TEI, except that:-->
        <!-- 1) we allow <g> in its content. -->
        <!-- 2) we restrict @scheme (currently to "wwp") -->
        <!-- 3) we don't allow @scope -->
        <!-- 4) we require either @selector or that we are pointed at by a @rendition -->
        <!-- 5) we restrict @selector a bit, but use 3 added pseudo-classes (see remarks) -->
        <elementSpec module="header" ident="rendition" mode="change">
          <content>
            <macroRef key="macro.xtext"/>
          </content>
          <constraintSpec scheme="schematron" ident="selector-required-if-pointed-at">
            <constraint>
              <sch:let name="myIDref" value="concat('#', normalize-space( @xml:id ) )"/>
              <sch:assert test="@selector or ( @xml:id and
                /wwp:TEI/wwp:text//@rendition[ $myIDref = tokenize( normalize-space( . ),' ') ]
                )">default <gi>rendition</gi> #<sch:value-of
                select="(@xml:id, count( preceding::wwp:rendition )+1 )[1]"
                /> is not the default for anything (no <att>selector</att> and not pointed to by <att>rendition</att>)</sch:assert>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="scheme" mode="change">
              <defaultVal>wwp</defaultVal>
              <valList type="closed" mode="change">
                <valItem ident="wwp" mode="add">
                  <gloss>Women Writers Project rendition ladder</gloss>
                  <desc>indicates that the content of the element uses
                  the WWP rendition ladders notation; indicates that
                  the <att>selector</att> attribute uses CSS plus
                  three special pseudo-classes, particularly for use
                  with <gi>mw</gi></desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="scope" mode="delete"/>
            <attDef ident="selector" mode="change" usage="opt">
              <!-- would be a good case for the old "mwa" -->
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef name="string">
                  <dataFacet name="pattern" value="\s*(((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*))?((\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty)|:not\((((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)|\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty))\)))*(\s*[>+~&#x20;&#x09;&#x0A;&#x0D;]\s*(((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*))?((\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty)|:not\((((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)|\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty))\)))*)*(::?(first-(line|letter)|before|after))?(,\s*(((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*))?((\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty)|:not\((((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)|\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty))\)))*(\s*[>+~&#x20;&#x09;&#x0A;&#x0D;]\s*(((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*))?((\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty)|:not\((((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?(\*|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)|\[\s*((-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|\*)?\|)?-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*\s*([$~*|^]?=\s*(&apos;([^&apos;]|\\&apos;)*&apos;|&quot;([^&quot;]|\\&quot;)*&quot;|-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*)\s*)?\]|\.-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|#-?([a-zA-Z_&#x00A0;-&#x10FFFF;]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))([a-zA-Z_&#x00A0;-&#x10FFFF;0-9\-]|\\([&#x21;-&#x10FFFF;-[a-fA-F0-9\n\r\t]]|[0-9a-fA-F]{1,6}\s?))*|:(link|visited|hover|active|focus|target|lang\((((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang))|((([A-Za-z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|[A-Za-z]{4}|[A-Za-z]{5,8})(-([A-Za-z]{4}))?(-([A-Za-z]{2}|[0-9]{3}))?(-([A-Za-z0-9]{5,8}|[0-9][A-Za-z0-9]{3}))*(-([0-9A-WY-Za-wy-z](-[A-Za-z0-9]{2,8}).))*(-(x(-[A-Za-z0-9]{1,8}).))?)|(x(-[A-Za-z0-9]{1,8}).))\)|enabled|disabled|checked|root|nth(-last)?-child\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|nth(-last)?-of-type\(\s*([+\-]?\s*[0-9]*n(\s*[+\-]?\s*[0-9]+)?|[+\-]?\s*[0-9]+|odd|even)\s*\)|(first|last|only)-(child|of-type)|empty))\)))*)*(::?(first-(line|letter)|before|after))?)*\s*"/>
                </dataRef>
              </datatype>
            </attDef>
          </attList>
          <remarks>
            <p>Note that vanilla TEI does not permit the <gi>g</gi>
            element in the content of <gi>rendition</gi>, but we do
            here at the WWP, as we have a lot of non-Unicode
            characters in <val>pre()</val> or <val>post()</val>.</p>
            <p>Note that the language used in <att>selector</att> is
            <emph>not</emph> CSS, but rather is <val>wwp</val>. The
            difference is that the WWP language has three additional psuedo-classes:
            <list type="gloss">
              <label>romulus</label><item>the first (or elder) of a
              pair of <soCalled>twin</soCalled> elements,
              i.e. elements of the same element type that occur with
              nothing between them except perhaps a whitespace-only
              text node.</item>
              <label>remus</label><item>the second (or younger) of a
              pair of <soCalled>twin</soCalled> elements, or any other
              than the first of a sequence of twin elements (i.e. a
              series of two or more elements of the same element type
              that occur with nothing between any two except perhaps
              whitespace-only text nodes).</item>
              <label>twinLess</label><item>an element that does not
              have a closest sibling of the same element type</item>
            </list>
            At the moment we only use these pseudo-classes with the
            selector for the element type <gi>mw</gi>.
            </p>
          </remarks>
        </elementSpec>
        <!-- In addition to having a completely new content model, <note> -->
        <!-- has a restricted value list for type=, and is not allowed -->
        <!-- to point directly to itself. -->
        <elementSpec module="core" ident="note" mode="change">
          <content>
            <macroRef key="macro.noteContent"/>
          </content>
          <constraintSpec scheme="schematron" ident="note-has-target">
            <constraint>
              <sch:rule context="wwp:text//wwp:note[not(@target)]">
                <sch:report test="ancestor::wwp:hyperDiv | ancestor::wwp:div[@type='endnotes']">ERROR: <sch:value-of
                select="if (@xml:id) then concat('the note with id=', @xml:id ) else concat('note #',count( preceding::wwp:note))"
                /> does not have a @target, but should (because it is an endnote or is inside ＜hyperDiv＞)</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="note-not-point-to-self">
            <constraint>
              <sch:rule context="wwp:note[@target|@targetEnd]">
                <sch:let name="ptr2me" value="concat('#', @xml:id )"/>
                <sch:report test="//wwp:note[ tokenize( string-join( ( @target, @targetEnd ), ' '),' ') = $ptr2me ]">ERROR: the note element with id=<sch:value-of select="@xml:id"/> refers to itself</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="textual-note-in-notesStmt">
            <constraint>
              <sch:rule context="wwp:note[ @type eq 'textual']">
              <sch:assert test="parent::wwp:notesStmt">textual notes should be in the <gi>notesStmt</gi> in the TEI header.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="non-modern-note-not-in-notesStmt">
            <constraint>
              <sch:rule context="wwp:note[ @type = ('editorial','authorial') ]">
              <sch:report test="parent::wwp:notesStmt"><sch:value-of select="@type"/> notes should not be in the <gi>notesStmt</gi> in the TEI header.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="target-points-back">
            <constraint>
              <sch:rule context="wwp:note[ ( not(@type)  or  @type eq 'authorial' )  and  @target ]">
                <sch:let name="myID" value="@xml:id"/>
                <!-- change string of whitespace-separated targets into a sequence -->
                <sch:let name="targets" value="tokenize( normalize-space( @target ), ' ')"/>
                <!-- strip off leading '#' of each -->
                <sch:let name="TARGETs" value="for $t in $targets return substring-after( $t,'#')"/>
                <!-- now compare the @corresp of the element that each points to to my ID -->
                <sch:let name="returnPointers_eq_me"
                         value="for $T in $TARGETs return substring-after( id( $T )/@corresp,'#') eq $myID"/>
                <!-- so we now have a sequence of booleans; if one are more are false, issue msg -->
                <sch:report test="$returnPointers_eq_me = false()">One or more of the values of <att>target</att> of the <gi>note</gi> with ID <sch:value-of select="$myID"/> points to an element whose <att>corresp</att> does not point back</sch:report>
                <sch:assert test="count( $targets ) &gt; 0">Empty @target of ＜note＞</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron"
                          ident="note_with_only_add_should_be_add_with_note">
            <constraint>
              <sch:report test="*/add
                                and
                                not( */text()[not( normalize-space(.) eq '' ) ] )">
                <gi>note</gi>&#xA0;<sch:value-of select="if (@xml:id)
                then concat('the note with id=', @xml:id ) else
                concat('note #',count( preceding::wwp:note))" />
                should probably be an <gi>add</gi> with a
                <gi>note</gi> inside instead, as it seems to have no
                content other than an <gi>add</gi>.</sch:report>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="replace">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <defaultVal>authorial</defaultVal>
              <valList type="closed">
                <valItem ident="authorial">
                  <desc>The note was written by the author, whether
                  contemporaneously with the rest of the text or
                  not.</desc>
                </valItem>
                <valItem ident="editorial">
                  <desc>The note was written by an editor or publisher.</desc>
                </valItem>
                <valItem ident="temp">
                  <desc>The note is intended for intra-WWP
                  communication, particularly to flag an issue to be
                  reslolved later; intent is to remove it after the
                  issue is resolved (hopefully, but not always, prior
                  to publication).</desc>
                </valItem>
                <valItem ident="public">
                  <!-- Used to be either "textual" or "WWP"[@target] -->
                  <desc>Indicates an editorial note (which may be in
                  the <gi>notesStmt</gi>) supplied by the encoder or
                  textbase editor, intended for public
                  consumption.</desc>
                </valItem>
                <valItem ident="internal">
                  <!-- Used to be "WWP"[not(@target)] -->
                  <desc>A note generated by WWP, not intended for
                  public consumption; often used for notes to our
                  future selves to avoid confusion or repeated
                  work.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <!-- <postscript> -->
        <elementSpec module="core" ident="postscript" mode="change">
          <classes mode="change">
            <memberOf key="att.declaring" mode="add"/>
          </classes>
          <content>
            <macroRef key="macro.noteContent"/>
          </content>
        </elementSpec>
        <!-- very restrictive content model of <extent> -->
        <elementSpec module="header" ident="extent" mode="change">
          <content>
            <alternate>
              <elementRef key="measure"/>
              <elementRef key="dimensions"/>
            </alternate>
          </content>
          <exemplum>
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
              <extent>
                <measure unit="pages" quantity="48"/>
              </extent>
              <extent>
                <dimensions unit="cm" type="leaves">
                  <format>quarto</format>
                  <height>19</height>
                  <width>13</width>
                </dimensions>
              </extent>
            </egXML>
          </exemplum>
        </elementSpec>
        <!-- also constrain values of reason= of <gap> -->
        <elementSpec module="core" ident="gap" mode="replace">
          <desc>indicates a point where material has been omitted in a
          transcription, whether for editorial reasons described in
          the TEI header, as part of sampling practice, or because the
          material is illegible, invisible, or inaudible.</desc>
          <!-- We will be using desc= rather than a child <desc>, because -->
          <!-- we are confident that we will never need to use chararcters -->
          <!-- not in Unicode or write descriptions in a different language. -->
          <classes mode="replace">
            <memberOf key="att.global"/>
            <!-- we aren't using <gap> for sound recordings or other timed things,  -->
            <!-- so att.duration is not in this list -->
            <memberOf key="model.global.edit"/>
            <memberOf key="att.dimensions"/>                   <!-- for @extent -->
            <!-- memberOf key="att.damaged" why did I put this here? this would be for Moodies, not WWP, no? -->
            <!-- in any case, it breaks the current schema roma generates, so I'm commenting it out for now. -->
          </classes>
          <content><empty/></content>
          <constraintSpec scheme="schematron" ident="gap-attr-combo">
            <constraint>
              <sch:report role="error"
                          test="
                                (
                                  @reason = ('damaged','deleted','obscured','flawed-reproduction','excerpt','other')
                                  and
                                  @desc = ('attachment','embossing')
                                )
                                or
                                ( @reason eq 'obscured'  and  @desc eq 'unknown' )
                                ">reason="<sch:value-of select="@reason"/>" and desc="<sch:value-of select="@desc"/>" of ＜gap＞ is an invalid combination</sch:report>
              <sch:report role="warning"
                          test="
                                (
                                  @reason = ('deleted','flawed-reproduction','excerpt','omitted','other')
                                  and
                                  @desc eq 'unknown'
                                )
                                or
                                (
                                  @reason eq 'other'  and  @desc = ('handwriting','printed')
                                )
                                ">are you sure the combination of reason="<sch:value-of select="@reason"/>" and desc="<sch:value-of select="@desc"/>" of ＜gap＞ makes sense?</sch:report>
              <sch:assert role="error"
                          test="if ( @desc eq 'other' )
                                then id( substring( normalize-space( @corresp ), 2 ) )[self::wwp:note]  
                                else true()">When the description is just "other", there should be a <gi>note</gi> explaining the gap (and @corresp should point to that note)</sch:assert>
            </constraint>
          </constraintSpec>
          <attList>
            <!--
                 What we want to do is:
                   <attRef class="att.dimensions" name="extent"/>
                   <attDef ident="extent" usage="req" mode="change"/>
                 But that does not make the attribute required. So instead we are a member
                 of att.dimensions, but we delete all but one of its attributes.
            -->
            <attDef ident="unit" mode="delete"/>
            <attDef ident="quantity" mode="delete"/>
            <attDef ident="extent" usage="req" mode="change"/>
            <attDef ident="precision" mode="delete"/>
            <attDef ident="scope" mode="delete"/>
            <attDef ident="reason" usage="req">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="damaged">
                  <desc>the text has been damaged due to tearing,
                  creasing, folding, fire, insects, etc.</desc>
                </valItem>
                <valItem ident="excerpt">
                  <desc>a portion of the text has been deliberately
                  omitted from the larger document as determined by
                  the WWP's editorial policy</desc>
                </valItem>
                <valItem ident="flawed-reproduction">
                  <desc>for cases where the illegibility is caused by
                  our reproduction of the text, and we have reason to
                  believe the original is still legible (e.g. edges
                  have been unintentionally cropped during copying or
                  filming, under- or over-exposure, objects
                  superimposed on the original when it was
                  reproduced)</desc>
                </valItem>
                <valItem ident="obscured">
                  <desc>the page is intact but the original text is
                  illegible for some reason other than deletion (e.g.
                  water staining, uninked letters)</desc>
                </valItem>
                <valItem ident="omitted">
                  <desc>for features which our policy is to ignore
                  (bookplates, embossing, stamping, modern
                  handwriting, etc.)</desc>
                </valItem>
                <valItem ident="other">
                  <desc>used only when none of the above values are
                  appropriate</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="unit" mode="replace" usage="rec">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="chars">
                  <gloss>characters</gloss>
                  <desc>characters of text</desc>
                </valItem>
                <valItem ident="words">
                  <desc>words, i.e. whitespace-separated tokens</desc>
                </valItem>
                <valItem ident="lines">
                  <desc>lines of text</desc>
                </valItem>
                <valItem ident="pages">
                  <desc>pages, i.e. one side of a leaf</desc>
                </valItem>
                <valItem ident="cm">
                  <gloss>centimetres</gloss>
                </valItem>
                <valItem ident="mm">
                  <gloss>millimetres</gloss>
                </valItem>
                <valItem ident="in">
                  <gloss>inches</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="hand" usage="opt">
              <desc>in the case of text omitted from the transcription
              because of deliberate deletion by an identifiable hand,
              signifies the hand which made the deletion.</desc>
              <datatype><dataRef key="teidata.pointer"/></datatype>
              <constraintSpec scheme="schematron" ident="hand_checks">
                <constraint>
                  <sch:pattern>
                    <sch:rule context="*[ starts-with( @hand,'#') ]">
                      <sch:assert test="//wwp:handNote[ @xml:id = substring-after( current()/@hand,'#') ]">hand= attribute of ＜<sch:name/>＞ does not point to a ＜handNote＞ (local)</sch:assert>
                    </sch:rule>
                    <sch:rule context="*[ contains( @hand,'#') ]">
                      <sch:assert
                          test="document( substring-before( @hand,'#') )
                                //wwp:handNote[ @xml:id = substring-after( current()/@hand,'#') ]">hand= attribute of ＜<sch:name/>＞ does not point to a ＜handNote＞ (external)</sch:assert>
                    </sch:rule>
                    <sch:rule context="*[@hand]">
                      <sch:report test="not(contains(@hand,'#'))">hand=
                      attribute of ＜<sch:name/>＞ must point to particular
                      ＜handNote＞ element via its xml:id=</sch:report>
                    </sch:rule>
                  </sch:pattern>
                  <sch:pattern>
                    <sch:rule context="wwp:gap[@hand|@agent|@degree|@group]">
                      <sch:assert test="substring-before( @reason, '-') ='damaged'"> The
                      hand=, agent=, degree=, and group= attributes of
                      ＜<sch:name/>＞ should only be specified if the reason= attribute is one that
                      indicates damage in the source (i.e., starts with “damaged-”).</sch:assert>
                    </sch:rule>
                  </sch:pattern>
                </constraint>
              </constraintSpec>
              <valDesc>must be one of the hand identifiers declared in
              the document header (see section <ptr target="#PHDH"/>).</valDesc>
            </attDef>
            <attDef ident="desc" usage="req">
              <valList type="closed">
                <valItem ident="attachment">
                  <desc>for anything stuck, glued, stapled, or
                  otherwise affixed to the page (e.g.
                  bookplates)</desc>
                </valItem>
                <valItem ident="embossing">
                  <desc>for anything added to the page by embossing or
                  other forms of pressure (including pricking holes in
                  the page)</desc>
                </valItem>
                <valItem ident="handwriting">
                  <desc>for handwriting that has been added to the
                  printed original</desc>
                </valItem>
                <valItem ident="printed">
                  <desc>for text or images printed on the page</desc>
                </valItem>
                <valItem ident="unknown">
                  <desc>for cases where we don't know what has been
                  omitted (e.g. if the page has been torn out and we
                  cannot tell what was on it)</desc>
                </valItem>
                <valItem ident="other">
                  <desc>used only when none of the above values are appropriate</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <remarks><p>The WWP version of <gi>gap</gi> has some
          additional restrictions and a transormation. The
          restrictoins are on the </p></remarks>
        </elementSpec>
        <elementSpec module="header" ident="textClass" mode="change">
          <desc xml:lang="en"/>
          <content>
            <elementRef key="catRef" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <remarks><p>The WWP version of this element is more
          restrictive than TEI, which permits other methods of
          indicating the text's classification.</p></remarks>
        </elementSpec>
        <elementSpec module="header" ident="taxonomy" mode="change">
          <desc xml:lang="en">explicitly defines a typology used to
          classify texts using a structured taxonomy.</desc>
          <content>
            <elementRef key="category" minOccurs="1" maxOccurs="unbounded"/>
          </content>
          <remarks><p>The WWP version of this element is more
          restrictive than TEI, which permits defining the taxonomy
          implicitly via a bibliographic reference to
          it.</p></remarks>
        </elementSpec>
        <!-- we allow <stage> and <label> inside <lg>, and <lg> inside <p>.-->
        <!-- Note that we also add the value list for type= while-->
        <!-- we're here. -->
        <elementSpec module="core" ident="lg" mode="change">
          <classes mode="change">
            <memberOf key="model.inter"/>
          </classes>
          <content>
            <sequence>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <classRef key="model.divTop"/>
                <classRef key="model.stageLike"/>
                <classRef key="model.global"/>
              </alternate>
              <alternate>
                <classRef key="model.lLike"/>
                <elementRef key="lg"/>
              </alternate>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <classRef key="model.lLike"/>
                <elementRef key="lg"/>
                <classRef key="model.stageLike"/>
                <classRef key="model.labelLike"/>
                <classRef key="model.global"/>
              </alternate>
              <sequence minOccurs="0" maxOccurs="unbounded">
                <classRef key="model.divBottom"/>
                <alternate minOccurs="0" maxOccurs="unbounded">
                  <classRef key="model.stageLike"/>
                  <classRef key="model.labelLike"/>
                  <classRef key="model.global"/>
                </alternate>
              </sequence>
            </sequence>
          </content>
          <attList>
            <attDef ident="type" mode="replace" usage="req">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="common">
                  <desc/>
                </valItem>
                <valItem ident="couplet">
                  <desc/>
                </valItem>
                <valItem ident="couplet-heroic">
                  <desc/>
                </valItem>
                <valItem ident="drama">
                  <desc/>
                </valItem>
                <valItem ident="indeterminate">
                  <desc/>
                </valItem>
                <valItem ident="octet">
                  <desc/>
                </valItem>
                <valItem ident="ottava-rima">
                  <desc/>
                </valItem>
                <valItem ident="para">
                  <desc/>
                </valItem>
                <valItem ident="poem">
                  <desc/>
                </valItem>
                <valItem ident="quatrain">
                  <desc/>
                </valItem>
                <valItem ident="quintet">
                  <desc/>
                </valItem>
                <valItem ident="refrain">
                  <desc/>
                </valItem>
                <valItem ident="rime-royal">
                  <desc/>
                </valItem>
                <valItem ident="section">
                  <desc/>
                </valItem>
                <valItem ident="septet">
                  <desc/>
                </valItem>
                <valItem ident="sestet">
                  <desc/>
                </valItem>
                <valItem ident="spenserian">
                  <desc/>
                </valItem>
                <valItem ident="stanza">
                  <desc/>
                </valItem>
                <valItem ident="tercet">
                  <desc/>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="subtype" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="dramatic-verse">
                  <desc/>
                </valItem>
                <valItem ident="verse">
                  <desc/>
                </valItem>
                <valItem ident="indeterminate">
                  <desc/>
                </valItem>
                <valItem ident="stanzaic">
                  <desc/>
                </valItem>
                <valItem ident="sonnet-shakespearean">
                  <desc/>
                </valItem>
                <valItem ident="sonnet">
                  <desc/>
                </valItem>
                <valItem ident="sonnet-petrarchan">
                  <desc/>
                </valItem>
                <valItem ident="acrostic">
                  <desc/>
                </valItem>
                <valItem ident="ode-english">
                  <desc/>
                </valItem>
                <valItem ident="spatial">
                  <desc/>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <!-- Allow <l> inside <p>; don't allow <l> within <l> -->
        <elementSpec module="core" ident="l" mode="change">
          <classes mode="change">
            <memberOf key="model.inter"/>
          </classes>
          <constraintSpec scheme="schematron" ident="no-nested-metrical-line">
            <constraint>
              <sch:report test="descendant::wwp:l">A metrical line should not contain a metrical line</sch:report>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <!-- for <respStmt> we insist on the name first, and -->
        <!-- either the names or the <resp>s are limited to 1 -->
        <elementSpec module="core" ident="respStmt" mode="change">
          <content>
            <classRef key="model.nameLike.agent"/>
            <alternate>
              <elementRef key="resp" minOccurs="1" maxOccurs="unbounded"/>
              <sequence>
                <classRef key="model.nameLike.agent" minOccurs="1" maxOccurs="unbounded"/>
                <elementRef key="resp"/>
              </sequence>
            </alternate>
          </content>
        </elementSpec>
        <!-- for <text> we add <hyperDiv> and require xml:id=  -->
        <elementSpec module="textstructure" ident="text" mode="change">
          <classes mode="change">
            <memberOf key="att.typed" mode="delete"/>
            <memberOf key="att.structuralCategorization" mode="add"/>
          </classes>
          <content>
            <!-- the same as TEI P5 except as commented -->
            <sequence>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              <sequence minOccurs="0">                                             <!-- wwp -->
                <elementRef key="hyperDiv"/>                                       <!-- wwp -->
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/> <!-- wwp -->
              </sequence>
              <sequence minOccurs="0">
                <elementRef key="front"/>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
              <alternate>
                <elementRef key="body"/>
                <elementRef key="group"/>
              </alternate>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              <sequence minOccurs="0">
                <elementRef key="back"/>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
            </sequence>
          </content>
          <constraintSpec scheme="schematron" ident="sub-text-ID-matches-text">
            <constraint>
              <sch:rule context="/wwp:TEI/wwp:teiHeader/wwp:text//wwp:text">
                <sch:let name="textID" value="normalize-space( /wwp:TEI/wwp:text/@xml:id )"/>
                <!-- yes, above is a duplicate of declaration in "TR_and_OT_nums" -->
                <sch:assert test="substring( normalize-space( @xml:id ), 1, 7 ) eq substring( $textID, 1, 7 )"
                            >sub-text TR# <sch:value-of select="@xml:id"/> does not match main text TR# <sch:value-of select="$textID"/>.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" usage="req" mode="change"/> <!-- wwp -->
          </attList>
        </elementSpec>

        <!-- ************************************************* -->
        <!-- required element section                          -->
        <!-- Sort of a subset of the previous section, here we -->
        <!-- require some elements that TEI says are optional. -->
        <!-- ************************************************* -->
        <!-- We'd like to do this the easy way ...
             <elementSpec module="header" usage="req" ident="textClass" mode="change"/>
             <elementSpec module="header" usage="req" ident="projectDesc" mode="change"/>
             <elementSpec module="header" usage="req" ident="samplingDecl" mode="change"/>
             <elementSpec module="header" usage="req" ident="editorialDecl" mode="change"/>
             <elementSpec module="header" usage="req" ident="classDecl" mode="change"/ -->
        <!-- ... but that doesn't work, as roma ignores the usage= attribute of -->
        <!-- <elementSpec>, and even if it didn't, these elements are included -->
        <!-- in content models by reference to a class model, so it probably -->
        <!-- wouldn't do what we want. Thus, we have to do the following. -->
        <elementSpec module="header" ident="teiHeader" mode="change">
          <constraintSpec scheme="schematron" ident="required_header_bits">
            <constraint>
              <sch:pattern>
                <sch:rule context="wwp:teiHeader">
                  <sch:assert test="wwp:profileDesc/wwp:textClass">The WWP requires at least one ＜textClass＞ element be present.</sch:assert>
                  <sch:assert test="wwp:fileDesc/wwp:editionStmt
                                    or
                                    wwp:fileDesc/xi:include[
                                      contains( @xpointer, 'WWPedition')
                                    ]">The WWP requires at least one ＜editionStmt＞ element be present or included.</sch:assert>
                  <sch:assert test="wwp:encodingDesc/wwp:projectDesc
                                    or
                                    wwp:encodingDesc/xi:include[
                                      contains( @xpointer, 'WWPprojectDescription')
                                    ]">The WWP requires at least one ＜projectDesc＞ element be present or included.</sch:assert>
                  <sch:assert test="wwp:encodingDesc/wwp:samplingDecl
                                    or
                                    wwp:encodingDesc/xi:include[
                                      contains( @xpointer, 'WWPsamplingDeclaration')
                                    ]">The WWP requires at least one ＜samplingDecl＞ element be present or included.</sch:assert>
                  <sch:assert test="wwp:encodingDesc/wwp:editorialDecl
                                    or
                                    wwp:encodingDesc/xi:include[
                                      contains( @xpointer, 'WWPeditorialDeclaration')
                                    ]">The WWP requires at least one ＜editorialDecl＞ element be present or included.</sch:assert>
                  <sch:assert test="wwp:encodingDesc/wwp:charDecl
                                    or
                                    wwp:encodingDesc/xi:include[
                                      contains( @xpointer, 'WWPcharacterDeclaration')
                                    ]">The WWP requires at least one ＜charDecl＞ element be present or included.</sch:assert>
                  <sch:assert test="wwp:encodingDesc/wwp:classDecl
                                    or
                                    wwp:encodingDesc/xi:include[
                                      contains( @xpointer, 'WWPclassificationDeclaration')
                                    ]">The WWP requires at least one ＜classDecl＞ element be present or included.</sch:assert>
                  <sch:assert test="wwp:encodingDesc/wwp:listPrefixDef
                                    or
                                    wwp:encodingDesc/xi:include[
                                      contains( @xpointer, 'WWPlistPrefixDefinitions')
                                    ]">The WWP requires at least one ＜listPrefixDef＞ element be present or included.</sch:assert>
                  <sch:assert test="wwp:encodingDesc/wwp:listPrefixDef">WARNING: ＜listPrefixDef＞ not found, so values of @ref will not be tested — if you are using the supraSchemas project, just ignore this warning; otherwise, to validate @refs, perform XInclude processing before validation (to do so in oXygen check “Enable XInclude Processing” in the XML / XML Parser / XInclude Options preferences pane)</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
        </elementSpec>

        <!-- ************************************************ -->
        <!-- attribute constraint section                     -->
        <!-- (attributes that are more constrained than       -->
        <!-- vanilla, e.g. constrained value list or required -->
        <!-- instead of optional)                             -->
        <!-- ************************************************ -->
        <!-- require @xml:lang on <foreign> here -->
        <elementSpec module="core" ident="foreign" mode="change">
          <attList>
            <attDef ident="xml:lang" mode="change" usage="req"/>
          </attList>
        </elementSpec>
        <classSpec module="tei" type="atts" ident="att.datable" mode="change">
          <constraintSpec ident="calendar_points_to_calendar" scheme="schematron">
            <constraint>
              <sch:rule context="*[@calendar]">
                <sch:assert test="/wwp:TEI/wwp:teiHeader/wwp:profileDesc/wwp:calendarDesc/wwp:calendar/@xml:id = substring( normalize-space(@calendar), 2 )"
                  >The @calendar attribute of <sch:value-of select="name(.)"
                  /> should point to a <gi>calendar</gi
                  > element, but this one ("<sch:value-of select="normalize-space(@calendar)"
                  />") does not; this error will always occur unless you perform XInclude processing before validation (to do so in oXygen check “Enable XInclude Processing” in the XML / XML Parser / XInclude Options preferences pane)</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
        </classSpec>
        <classSpec module="tei" type="atts" ident="att.spanning" mode="change">
          <attList>
            <attDef ident="spanTo" usage="opt" mode="change">
              <constraintSpec ident="spanTo-to-anchor" scheme="schematron">
                <desc>The @spanTo attribute must point to an <gi>anchor</gi> element</desc>
                <constraint>
                  <sch:rule context="wwp:*[@spanTo]">
                    <sch:let name="spanTo" value="substring(@spanTo,2)"/>
                    <sch:let name="spanEnd" value="id( $spanTo )"/>
                    <sch:assert test="$spanEnd/self::wwp:anchor">
                      The @spanTo of <gi><sch:name/></gi> must point to an <gi>anchor</gi>; this one (<val><sch:value-of
                      select="@spanTo"/></val>) points to a <gi><sch:value-of select="local-name($spanEnd)"/></gi>.
                    </sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </classSpec>
        <elementSpec module="linking" ident="ab" mode="change">
          <attList>
            <attDef ident="type" mode="change">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList mode="replace" type="closed">
                <valItem ident="caption">
                  <desc> </desc>
                </valItem>
                <valItem ident="issue">
                  <desc> </desc>
                </valItem>
                <valItem ident="commentary">
                  <desc> </desc>
                </valItem>
                <valItem ident="timelineitem">
                  <desc> </desc>
                </valItem>
                <valItem ident="placeholder">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="list" mode="change">
          <classes mode="change">
            <memberOf key="model.biblPart"/>
          </classes>
          <attList>
            <attDef ident="type" mode="replace">
              <valList type="closed">
                <valItem ident="toc">
                  <gloss>table of contents</gloss>
                  <desc> </desc>
                </valItem>
                <valItem ident="errata">
                  <desc> </desc>
                </valItem>
                <valItem ident="subscriber">
                  <desc> </desc>
                </valItem>
                <valItem ident="gloss">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="gaiji" ident="mapping" mode="change">
          <attList>
            <attDef ident="value" mode="add">
              <desc>The Unicode Standard Notation of the character(s) to which
              the character or glyph being described should be mapped.</desc>
              <datatype minOccurs="1" maxOccurs="8">
                <dataRef key="teidata.word" restriction="^U\+[0-9A-F]{4,6}$"/>
              </datatype>
              <remarks><p>Since this is a space-separated list of
              values, if you actually need to indicate a space use
              <val>U+0020</val>.</p></remarks>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="gaiji" ident="g" mode="change">
          <content><empty/></content>
          <attList>
            <attDef ident="ref" mode="change" usage="req">
              <constraintSpec scheme="schematron" ident="g-points-to-char">
                <!-- Note: this constraint may not work with
                     `probatron`, but works fine in oXygen. -->
                <constraint>
                  <sch:rule context="wwp:g[@ref][/wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef]">
                    <sch:let name="ref" value="substring( normalize-space( @ref ), 2 )"/>
                    <sch:let name="reffed"
                             value="if ( //wwp:charDecl )
                                    then id( $ref )
                                    else
                                      document('../common-boilerplate.xml', /) // *[ @xml:id eq $ref ]"/>
                    <sch:let name="test" value="$reffed[ self::wwp:char ]"/>
                    <sch:assert test="$test">The @ref of ＜g＞ should point to a ＜char＞; this one (<sch:value-of select="."/>) points to <sch:value-of
                    select="if ($reffed)
                            then concat('a ＜', name($reffed),'＞')
                            else 'nothing'"/>.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
          <remarks>
            <p>At the WWP, <gi>g</gi> is further constrained (than
            vanilla TEI) as follows: <list>
            <item>must be empty</item>
            <item>must have a <att>ref</att> attribute</item>
            <item>the <att>ref</att> attribute must point to a <gi>char</gi></item>
            </list>
            </p>
          </remarks>
        </elementSpec>
        <elementSpec module="core" ident="persName" mode="change">
          <constraintSpec mode="add" scheme="schematron" ident="persName-refers-to-person">
            <constraint>
              <sch:pattern>
                <!-- I'd prefer to use the attribute, i.e. wwp:persName/@ref, as the-->
                <!-- context node, but Probatron doesn't seem to like that. -->
                <!-- That last predicate in each of the 4 clauses in the @context, below, ensures -->
                <!-- that we are testing in an environment in which it is possible to succeed, i.e. -->
                <!-- in which the appropriate <prefixDef> *can* be found. (Because if this validation -->
                <!-- is happening before XInclude processing, we won't be able to find the <prefixDef>, -->
                <!-- and thus will not find the personography, and thus will think every pointer fails.) -->
                <sch:rule context="wwp:persName[@ref][/wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef]
                                   | wwp:change[@who][/wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef]
                                   | *[@author][/wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef]
                                   | *[@resp][/wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef]">
                  <sch:let name="path" value="'https://www.wwp-test.neu.edu/wwo/texts/'"/>
                  <sch:let name="att" value="if      (self::wwp:persName and @resp) then 'UNDETERMINED'
                                             else if (self::wwp:persName)           then 'ref'
                                             else if (self::wwp:change and @resp)   then 'UNDETERMINED'
                                             else if (self::wwp:change)             then 'who'
                                             else if ( self::wwp:p
                                                     | self::wwp:gloss
                                                     | self::wwp:term
                                                     | self::wwp:ptr
                                                     | self::wwp:ref
                                                     | self::wwp:graphic
                                                     | self::wwp:lg
                                                     | self::wwp:ab
                                                     | self::wwp:text
                                                     | self::wwp:body
                                                     | self::wwp:group
                                                     | self::wwp:floatingText
                                                     | self::wwp:div
                                                     | self::wwp:postscript
                                                     | self::wwp:front
                                                     | self::wwp:back  and  @resp)  then 'UNDETERMINED'
                                             else if ( self::wwp:p
                                                     | self::wwp:gloss
                                                     | self::wwp:term
                                                     | self::wwp:ptr
                                                     | self::wwp:ref
                                                     | self::wwp:graphic
                                                     | self::wwp:lg
                                                     | self::wwp:ab
                                                     | self::wwp:text
                                                     | self::wwp:body
                                                     | self::wwp:group
                                                     | self::wwp:floatingText
                                                     | self::wwp:div
                                                     | self::wwp:postscript
                                                     | self::wwp:front
                                                     | self::wwp:back)              then 'author'
                                             else                                        'resp'
                                             "/>
                  <sch:let name="val" value="normalize-space( string-join( ( @ref, @who, @resp, @author ), ' ') )"/>
                  <sch:let name="gi" value="local-name(.)"/>
                  <!-- get a sequence of the references in $val -->
                  <sch:let name="REFs" value="tokenize( normalize-space( $val ), ' ')"/>
                  <!-- get a sequence of the prefixes thereof[1] -->
                  <sch:let name="PREFs"
                           value="for $r in $REFs return substring-before( $r,':')"/>
                  <!-- get a sequence of the URLs associated with each prefix[1] -->
                  <sch:let name="URLs"
                           value="for $p in $PREFs return
                                  concat( $path, substring-before( /wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef//wwp:prefixDef[ @ident eq $p ]/@replacementPattern, '#' ) )"/>
                  <!-- get a sequence of the keys associated with each prefix[1] -->
                  <sch:let name="KEYs"
                           value="for $r in $REFs return substring-after( $r,':')"/>
                  <!-- get a sequence of the elements pointed to by each key in the corresponding URL; -->
                  <!-- If, for some reason, the URL & KEY combination does not point to a TEI element, -->
                  <!-- record the current node as the target (thus we can test later to see if the     -->
                  <!-- pointer failed by testing for the current node).                                -->
                  <sch:let name="PERSONs"
                           value="for $k in $KEYs return
                                    if ( count( index-of( $KEYs, $k ) ) eq 1 )
                                    then 
                                      if ( doc-available( $URLs[ index-of( $KEYs, $k )] ) )
                                      then
                                        if ( document( $URLs[ index-of( $KEYs, $k )] )//TEI:*[ @xml:id eq $k ] )
                                        then
                                          document( $URLs[ index-of( $KEYs, $k )] )//TEI:*[ @xml:id eq $k ]
                                        else .
                                      else .
                                    else ."/>
                  <!-- If there are no references in @ref, that's an error; report it -->
                  <sch:report test="count( $REFs ) eq 0">Empty @<sch:value-of select="$att"/> of ＜<sch:value-of select="$gi"/>＞</sch:report>
                  <!-- If there are any references that point to something other than <tei:person>, -->
                  <!-- report it (them).                                                            -->
                  <sch:report test="count( $PERSONs[ not( self::TEI:person ) ] ) gt 0">Each pointer in the <sch:value-of select="$att"/> attribute of ＜<sch:value-of select="$gi"/>＞ should point to a ＜person＞, but the pointers in this one ("<sch:value-of select="$val"/>") point to: <sch:value-of
                  select="if ( not( $PERSONs ) )
                          then 'nowhere'
                          else for $p in $PERSONs return
                            if ( $p is . )
                            then ' nothing'
                            else concat(' ＜', name($p), '＞')"/>.</sch:report>
                </sch:rule>
                <!-- [1] The PREFs, URLs, KEYs, and PERSONs sequences
                     have the same number of items as the REFs
                     sequence, but some of the items may be nil. -->
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="properAdjective">
                  <desc> </desc>
                </valItem>
                <valItem ident="regularized">
                  <desc> </desc>
                </valItem>
                <valItem ident="titlePage">
                  <desc> </desc>
                </valItem>
                <valItem ident="person-female">
                  <desc> </desc>
                </valItem>
                <valItem ident="person">
                  <desc> </desc>
                </valItem>
                <valItem ident="person-male">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="floatingText" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart" mode="add"/>
            <memberOf key="att.typed" mode="delete"/>
            <memberOf key="att.structuralCategorization" mode="add"/>
          </classes>
          <content>
            <!-- the same as TEI P5 except as commented -->
            <sequence>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              <sequence minOccurs="0">                                             <!-- wwp -->
                <elementRef key="hyperDiv"/>                                       <!-- wwp -->
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/> <!-- wwp -->
              </sequence>                                                          <!-- wwp -->
              <sequence minOccurs="0">
                <elementRef key="front"/>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
              <alternate>
                <elementRef key="body"/>
                <elementRef key="group"/>
              </alternate>
              <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              <sequence minOccurs="0">
                <elementRef key="back"/>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
            </sequence>
          </content>
          <constraintSpec scheme="schematron" ident="floating-text-ID-matches-text">
            <constraint>
              <sch:let name="textID" value="normalize-space( /wwp:TEI/wwp:text/@xml:id )"/>
              <!-- yes, above is a duplicate of declaration in "TR_and_OT_nums" -->
              <sch:assert test="substring( normalize-space( @xml:id ), 1, 7 ) eq substring( $textID, 1, 7 )"
                          >floatingText TR# <sch:value-of select="@xml:id"/> does not match main text TR# <sch:value-of select="$textID"/>.</sch:assert>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="xml:id" usage="req" mode="change"/>   <!-- wwp -->
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="label" mode="change">
          <attList>
            <attDef mode="replace" ident="type">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="speaker">
                  <desc>if this were drama, would be a <gi>speaker</gi></desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="header" ident="idno" mode="change">
          <attList>
            <attDef ident="type" usage="opt" mode="replace">
              <desc>categorizes the number, for example as an ISBN or
              other standard series.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <!-- values in following order: libraries, catalogues,
                     others; alphabetical by ident= within each (at
                     least for now) -->
                <!-- library codes; MARC first, then WWP-specific -->
                <valItem ident="clu">
                  <gloss>University of California, Los Angeles</gloss>
                </valItem>
                <valItem ident="cluc">
                  <gloss>William Andrews Clark Memorial Library</gloss>
                </valItem>
                <valItem ident="csmh">
                  <gloss>Henry E. Huntington Library</gloss>
                </valItem>
                <valItem ident="cty">
                  <gloss>Yale University, Sterling Memorial Library</gloss>
                </valItem>
                <valItem ident="ctybr">
                  <gloss>Yale University, Beinecke Library</gloss>
                </valItem>
                <valItem ident="dfo">
                  <gloss>Folger Shakespeare Library</gloss>
                </valItem>
                <valItem ident="dlc">
                  <gloss>US Library of Congress</gloss>
                </valItem>
                <valItem ident="icj">
                  <gloss>John Crerar Library</gloss>
                </valItem>
                <valItem ident="icjkm">
                  <gloss>Jesuit Krauss McCormick Library</gloss>
                </valItem>
                <valItem ident="icn">
                  <gloss>Newberry Library </gloss>
                </valItem>
                <valItem ident="icrl">
                  <gloss>Center for Research Libraries</gloss>
                </valItem>
                <valItem ident="icu">
                  <gloss>University of Chicago</gloss>
                </valItem>
                <valItem ident="ien">
                  <gloss>Northwestern University</gloss>
                </valItem>
                <valItem ident="inre">
                  <gloss>Earlham College Library</gloss>
                </valItem>
                <valItem ident="inu">
                  <gloss>Indiana University</gloss>
                </valItem>
                <valItem ident="iu">
                  <gloss>University of Illinois, Urbana</gloss>
                </valItem>
                <valItem ident="mb">
                  <gloss>Boston Public Library</gloss>
                </valItem>
                <valItem ident="mbat">
                  <gloss>Boston Athenæum</gloss>
                </valItem>
                <valItem ident="mbco">
                  <gloss>Harvard University Medical School, Countway Library</gloss>
                </valItem>
                <valItem ident="mh">
                  <gloss>Harvard University</gloss>
                </valItem>
                <valItem ident="mhh">
                  <gloss>Harvard University, Houghton Library</gloss>
                </valItem>
                <valItem ident="miu">
                  <gloss>University of Michigan</gloss>
                </valItem>
                <valItem ident="mns">
                  <gloss>Smith College</gloss>
                </valItem>
                <valItem ident="mwa">
                  <gloss>American Antiquarian Society</gloss>
                </valItem>
                <valItem ident="nbrocku">
                  <gloss>State University of New York, College at Brockport</gloss>
                </valItem>
                <valItem ident="nhd">
                  <gloss>Dartmouth College</gloss>
                </valItem>
                <valItem ident="njp">
                  <gloss>Princeton University</gloss>
                </valItem>
                <valItem ident="nn">
                  <gloss>New York Public Library</gloss>
                </valItem>
                <valItem ident="nnc">
                  <gloss>Columbia University</gloss>
                </valItem>
                <valItem ident="nnut">
                  <gloss>Union Theological Seminary</gloss>
                </valItem>
                <valItem ident="npv">
                  <gloss>Vassar College Library</gloss>
                </valItem>
                <valItem ident="pp">
                  <gloss>Free Library of Philadelphia</gloss>
                </valItem>
                <valItem ident="pu">
                  <gloss>University of Pennsylvania</gloss>
                </valItem>
                <valItem ident="rpb">
                  <gloss>Brown University</gloss>
                </valItem>
                <valItem ident="rpjcb">
                  <gloss>John Carter Brown Library</gloss>
                </valItem>
                <valItem ident="uk">
                  <gloss>British Library [duplicate]</gloss>
                </valItem>
                <valItem ident="uk">
                  <gloss>British Library</gloss>
                </valItem>
                <valItem ident="ukcu">
                  <gloss>Cambridge University</gloss>
                </valItem>
                <valItem ident="uklougc">
                  <gloss>University  of London, Goldsmith’s  Library</gloss>
                </valItem>
                <valItem ident="uklpr">
                  <gloss>Public Record Office, London</gloss>
                </valItem>
                <valItem ident="ukmajru">
                  <gloss>John Rylands Library, University of Manchester</gloss>
                </valItem>
                <valItem ident="ukoxu">
                  <gloss>Bodleian Library</gloss>
                </valItem>
                <valItem ident="ukoxu">
                  <gloss>Oxford University, Bodleian Library [duplicate]</gloss>
                </valItem>
                <valItem ident="viu">
                  <gloss>University of Virginia</gloss>
                </valItem>
                <valItem ident="wimauma">
                  <gloss>University of Wisconsin Madison Archives</gloss>
                </valItem>
                <valItem ident="wlabnl">
                  <gloss>National Library of Wales</gloss>
                </valItem>
                <!-- library codes above this are MARC codes;-->
                <!-- library codes below this are WWP-specific codes -->
                <valItem ident="unknown">
                  <gloss>unknown</gloss>
                </valItem>
                <valItem ident="wwp:corvey">
                  <gloss>The Corvey Library, Germany</gloss>
                </valItem>
                <valItem ident="wwp:hindle">
                  <gloss>C. J. Hindle collection, Bodleian</gloss>
                </valItem>
                <valItem ident="wwp:iedt">
                  <gloss>Trinity College, Dublin</gloss>
                </valItem>
                <valItem ident="wwp:ukblt">
                  <gloss>Thomason Collection, British Library</gloss>
                </valItem>
                <valItem ident="wwp:ukoxw">
                  <gloss>Worcester College, Oxford</gloss>
                </valItem>
                <!-- catalogue values of type= of <idno> -->
                <valItem ident="Evans">
                  <gloss> </gloss>
                </valItem>
                <valItem ident="STC">
                  <gloss>Short Title Catalogue</gloss>
                </valItem>
                <valItem ident="Wing">
                  <gloss> </gloss>
                </valItem>
                <!-- other (non-library, non-catalogue) values of
                     type= of <idno> -->
                <valItem ident="Ca-MvGOO">
                  <gloss>Google</gloss>
                  <desc>Google Books</desc>
                </valItem>
                <valItem ident="MiAaHDL">
                  <gloss>Hathitrust</gloss>
                </valItem>
                <valItem ident="MiAaPQ">
                  <gloss>Proquest</gloss>
                  <desc>I.e., EEBO and ECCO.</desc>
                </valItem>
                <valItem ident="URL">
                  <gloss>Uniform Resource Locator</gloss>
                  <desc>This element contains the URL that points to
                  the WWO <soCalled>browsing</soCalled> version of
                  this file. Typically
                  <code>http://www.wwp.northeastern.edu/texts/</code>
                  followed by the name of the file with
                  <code>.html</code> instead of
                  <code>.xml</code>.</desc>
                </valItem>
                <valItem ident="unknown">
                  <gloss>unknown</gloss>
                </valItem>
                <valItem ident="WWP">
                  <gloss>Women Writers Project</gloss>
                  <desc>This element contains the WWP transcription
                  number, as obtained from the OT database. Generally
                  speaking should match the regular expression
                  <code>TR[0-9]{5}</code>. The same string is used as
                  the value of <att>xml:id</att> of the main
                  <gi>text</gi>.</desc>
                </valItem>
              </valList>
              <remarks>
                <p>Values are listed with libraries first followed by
                catalogues followed by other values.</p>
                <p>Most of these codes are obtained from <ref
                target="https://www.loc.gov/marc/organizations/org-search.php">MARC</ref>
                at the Library of Congress. Several, prefixed with
                <code>wwp:</code>, are constructed in a similar manner
                to MARC codes (e.g., using the country code as the
                first few chars) by the WWP because, at the time we
                added that library, MARC did not have a code for
                it.</p>
              </remarks>
            </attDef>
          </attList>
          <listRef>
            <ptr target="#HD24"/>
            <ptr target="#HD26"/>
            <ptr target="#COBICOI"/>
          </listRef>
        </elementSpec>
        <elementSpec module="textstructure" ident="titlePart" mode="change">
          <!-- We also add <docRole> to the content model -->
          <content>
            <alternate minOccurs="1" maxOccurs="unbounded">
              <macroRef key="macro.paraContent"/>
              <elementRef key="docAuthor"/>
            </alternate>
          </content>
          <attList>
            <attDef ident="type" usage="req" mode="replace">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="closed">
                <valItem ident="address">
                  <desc> </desc>
                </valItem>
                <valItem ident="alt">
                  <desc> </desc>
                </valItem>
                <valItem ident="date">
                  <desc> </desc>
                </valItem>
                <valItem ident="desc">
                  <desc> </desc>
                </valItem>
                <valItem ident="main">
                  <desc> </desc>
                </valItem>
                <valItem ident="reason">
                  <desc> </desc>
                </valItem>
                <valItem ident="second">
                  <desc> </desc>
                </valItem>
                <valItem ident="sub">
                  <desc> </desc>
                </valItem>
                <valItem ident="vol">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
          <remarks><p>The WWP version of this element is more
          permissive than the TEI version: we permit <gi>docRole</gi>
          (structurally <gi>docAuthor</gi>).</p></remarks>
        </elementSpec>
        <elementSpec module="core" ident="head" mode="change">
          <attList>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="sub">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="ptr" mode="change">
          <attList>
            <!-- as we are not handling <regMe> yet (if ever)-:, and TEI ODD processing -->
            <!-- currently fails to do the right thing with attributes in alternation, -->
            <!-- we'll just delete cRef= -->
            <attDef ident="cRef" mode="delete"/>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="correction">
                  <desc> </desc>
                </valItem>
                <valItem ident="div">
                  <desc> </desc>
                </valItem>
                <valItem ident="error">
                  <desc> </desc>
                </valItem>
                <valItem ident="pageNum">
                  <desc> </desc>
                </valItem>
                <valItem ident="pageRange">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="rs" mode="change">
          <attList>
            <attDef ident="type" mode="replace" usage="req">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="teidata.enumerated"/>
              </datatype>
              <valList type="closed">
                <valItem ident="collectivity">
                  <desc> </desc>
                </valItem>
                <valItem ident="person">
                  <desc> </desc>
                </valItem>
                <valItem ident="place">
                  <desc> </desc>
                </valItem>
                <valItem ident="properAdjective">
                  <desc> </desc>
                </valItem>
                <valItem ident="source">
                  <desc> </desc>
                </valItem>
                <valItem ident="title">
                  <desc> </desc>
                </valItem>
                <valItem ident="ufo">
                  <gloss>unspecified feature used for organization</gloss>
                  <desc>Used to encoding a string to refer the reader
                  to another portion of the document, typically by
                  quoting its <gi>head</gi>; an internal cross
                  reference.</desc>
                </valItem>
                <valItem ident="verb">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="name" mode="change">
          <attList>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="properAdjective">
                  <desc> </desc>
                </valItem>
                <valItem ident="file">
                  <gloss>filename or filepath</gloss>
                  <desc>An operating system filepath or filename</desc>
                </valItem>
                <valItem ident="class">
                  <desc>A TEI attribute or model class</desc>
                </valItem>
                <valItem ident="macro">
                  <desc>A TEI macro</desc>
                </valItem>
                <valItem ident="constraint">
                  <desc>A TEI constraint; i.e., the value of the <att>ident</att> attribute
                  of a <gi>constraintSpec</gi></desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="placeName" mode="change">
          <constraintSpec scheme="schematron" ident="placeName-refers-to-place">
            <constraint>
              <sch:pattern>
                <!-- I'd prefer to use the attribute, i.e. wwp:placeName/@ref, as the-->
                <!-- context node, but Probatron doesn't seem to like that. -->
                <!-- That last predicate in each of the 3 clauses in the @context, below, ensures -->
                <!-- that we are testing in an environment in which it is possible to succeed, i.e. -->
                <!-- in which the appropriate <prefixDef> *can* be found. (Because if this validation -->
                <!-- is happening before XInclude processing, we won't be able to find the <prefixDef>, -->
                <!-- and thus will not find the personography, and thus will think every pointer fails.) -->
                <sch:rule context=
                          "wwp:placeName[@ref][/wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef]">
                  <sch:let name="path" value="'https://www.wwp-test.neu.edu/wwo/texts/'"/>
                  <sch:let name="val" value="normalize-space( @ref )"/>
                  <sch:let name="gi" value="local-name(.)"/>
                  <!-- get a sequence of the references in $val -->
                  <sch:let name="REFs" value="tokenize( $val, ' ')"/>
                  <!-- get a sequence of the prefixes thereof[1] -->
                  <sch:let name="PREFs"
                           value="for $r in $REFs return substring-before( $r,':')"/>
                  <!-- get a sequence of the URLs associated with each prefix[1] -->
                  <sch:let name="URLs"
                           value="for $p in $PREFs return
                                  concat( $path, substring-before( /wwp:TEI/wwp:teiHeader/wwp:encodingDesc/wwp:listPrefixDef//wwp:prefixDef[ @ident eq $p ]/@replacementPattern, '#' ) )"/>
                  <!-- get a sequence of the keys associated with each prefix[1] -->
                  <sch:let name="KEYs"
                           value="for $r in $REFs return substring-after( $r,':')"/>
                  <!-- get a sequence of the elements pointed to by each key in the corresponding URL; -->
                  <!-- If, for some reason, the URL & KEY combination does not point to a TEI element, -->
                  <!-- record the current node as the target (thus we can test later to see if the     -->
                  <!-- pointer failed by testing for the current node).                                -->
                  <sch:let name="PLACEs"
                           value="for $k in $KEYs return
                                    if ( doc-available( $URLs[ index-of( $KEYs, $k )] ) )
                                    then
                                      if ( document( $URLs[ index-of( $KEYs, $k )] )//TEI:*[ @xml:id eq $k ] )
                                      then
                                        document( $URLs[ index-of( $KEYs, $k )] )//TEI:*[ @xml:id eq $k ]
                                      else .
                                    else ."/>
                  <!-- If there are no references in @ref, that's an error; report it -->
                  <sch:report test="count( $REFs ) eq 0">Empty @ref of ＜placeName＞</sch:report>
                  <!-- If there are any references that point to something other than <tei:place>, -->
                  <!-- report it (them).                                                            -->
                  <sch:report test="count( $PLACEs[ not(
                                    self::TEI:place ) ] ) gt 0">Each pointer in the @ref attribute of ＜placeName＞ should point to a ＜place＞, but the pointers in this one ("<sch:value-of select="$val"/>") point to: <sch:value-of
                  select="if ( not( $PLACEs ) )
                          then 'nowhere'
                          else for $p in $PLACEs return
                            if ( $p is . )
                            then ' nothing'
                            else concat(' ＜', name($p), '＞')"/>.</sch:report>
                </sch:rule>
                <!-- [1] The PREFs, URLs, KEYs, and PLACEs sequences
                     have the same number of items as the REFs
                     sequence, but some of the items may be nil. -->
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="properAdjective">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="linking" ident="link" mode="change">
          <attList>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="grouped">
                  <desc>for cases when sections of text are grouped in a way not otherwise reflected in the encoding
                  (e.g., two <gi>row</gi>s in a <gi>table</gi> are braced to indicate a shared relationship)</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="ref" mode="change">
          <classes mode="change">
            <memberOf key="model.noteTop"/>
          </classes>
          <attList>
            <!-- as we are not handling <regMe> yet (if ever)-:, and TEI ODD processing -->
            <!-- currently fails to do the right thing with attributes in alternation, -->
            <!-- we'll just delete cRef= -->
            <attDef ident="cRef" mode="delete"/>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="correction">
                  <desc> </desc>
                </valItem>
                <valItem ident="div">
                  <desc> </desc>
                </valItem>
                <valItem ident="error">
                  <desc> </desc>
                </valItem>
                <valItem ident="pageNum">
                  <desc> </desc>
                </valItem>
                <valItem ident="pageRange">
                  <desc> </desc>
                </valItem>
                <valItem ident="goTo">
                  <desc> </desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="stage" mode="change">
          <attList>
            <attDef ident="type" mode="replace" usage="req">
              <desc versionDate="2015-07-01" xml:lang="en">indicates the type of stage direction.</desc>
              <datatype minOccurs="1" maxOccurs="5"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="business">
                  <desc>describes stage business—that is, some
                  activity taking place while the lines are being
                  spoken (for example, “While toying with her fan” or
                  “Rocks fall from above”)</desc>
                </valItem>
                <valItem ident="delivery">
                  <desc>describes the delivery of a line, either to
                  whom or in what manner it is spoken (for example,
                  “Sotto voce”, “Aside”, “To Acrasia”); this should be
                  distinguished from stage business, which describes
                  accompanying action rather than the speech
                  itself</desc>
                </valItem>
                <valItem ident="entrance">
                  <desc>describes an entrance to the stage (for instance, “Enter, a Clown”)</desc>
                </valItem>
                <valItem ident="exit">
                  <desc>describes an exit from the stage (for example, “Exits”, “Exeunt omnes”)</desc>
                </valItem>
                <valItem ident="location">
                  <desc>describes the location from which a line is
                  delivered (such as “From the couch”, “At the door”,
                  or “Seated at the table”); this should not be
                  confused with <val>setting</val>, which describes
                  aspects of the entire scene rather than the position
                  of a character for a particular line</desc>
                </valItem>
                <valItem ident="modifier">
                  <desc>describes a character's appearance or some
                  detail of that character (for example, “Disguised as
                  a juggler”, “Wearing a fright wig”, “Laden with tin
                  pots”)</desc>
                </valItem>
                <valItem ident="novelistic">
                  <desc>describes the state of mind or motivations of
                  a character, as if from an omniscient narrator's
                  point of view (for example, “Fed up with the
                  situation, and becoming impatient”, “Wondering what
                  she means”, “Privately contemplating escape”)</desc>
                </valItem>
                <valItem ident="present">
                  <desc>used in cases where a stage direction gives
                  the names of characters present on the stage without
                  offering any further information on their appearance
                  or actions (for example, “Alice and Amelia”)</desc>
                </valItem>
                <valItem ident="prop">
                  <desc>describes props that are onstage or indicates
                  the presence of props (for example “the shield of
                  Minerva”); this value should be used only when props
                  are significant in the text</desc>
                </valItem>
                <valItem ident="remains">
                  <desc>indcates characters who remain on the stage
                  when others exit (for example “manet
                  Norfolk”)</desc>
                </valItem>
                <valItem ident="setting">
                  <desc>indicates a setting for the dramatic scene,
                  possibly involving some details of stage layout,
                  lighting, time, place, or occasion (for instance, “A
                  ballroom lit with candles, soft music playing” or
                  “Venice in the seventeenth century, the sky bright
                  with the early light of a summer morning”)</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="milestone" mode="change">
          <constraintSpec ident="idealSignature" scheme="schematron">
	    <desc>Test that the <att>n</att> of a <gi>milestone</gi>
	    that has a <att>unit</att> of <val>sig</val> has as its
	    value a reasonable idealized signature. Note that this
	    constraint is curently fired for <emph>all</emph>
	    <gi>milestone</gi> elements. Luckily there are none other
	    than idealized signatures.</desc>
            <constraint>
              <sch:let name="me" value="normalize-space(@n)"/>
              <sch:assert test="
				matches( $me,'((facing|preceding)&#x20;)?(\p{L}|\p{M}|\p{N}|\p{P}|\p{S})*[0-9]+[\])]?[rv]')">
                The idealized signature “<sch:value-of
                select="."/>” does not match the defintion thereof.
              </sch:assert>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="unit" mode="replace" usage="req">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="sig">
                  <desc>An idealized leaf signature. Typically should
                  be a sequence of characters that indicate the
                  printed signature (or what would be the printed
                  signature if there were one) or first part thereof
                  followed by a number (if the printed signature did
                  not end with a number) and either ‘r’ (recto) or ‘v’
                  (verso), all optionally preceded by the word
                  “facing” or “preceding” and a space. See
                  https://www.wwp.neu.edu/research/publications/documentation/internal/#!/entry/signatures_narrative.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="unclear" mode="change">
          <attList>
            <attDef ident="reason" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="damaged">
                  <desc>the original page has been damaged through tearing, folding, creasing, foxing, fire or water damage, etc.</desc>
                </valItem>
                <valItem ident="flawed-reproduction">
                  <desc>for cases where the reproduction of the source document causes illegiblity but we have reason to believe the original is still legible (i.e. photocopies with insufficient contrast, smearing, edges cut off during filming, underexposure, etc.)</desc>
                </valItem>
                <valItem ident="obscured">
                  <desc>the original page is intact but the text is illegible due to poorly inked type, patches applied to the original page surface, partial deletion, etc.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="title" mode="change">
          <attList>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="sub">
                  <desc>indicates a subtitle</desc>
                </valItem>
                <valItem ident="main">
                  <desc>used for the primary or main title of the work</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="linking" ident="anchor" mode="change">
          <attList>
            <attDef ident="xml:id" usage="req" mode="change"/>
          </attList>
        </elementSpec>
        <!-- xml:id= required on <text> in altered content model section -->
        <elementSpec module="core" ident="sp" mode="change">
          <attList>
            <attDef ident="who" usage="req" mode="change">
              <constraintSpec ident="who-points-to-role" scheme="schematron">
                <constraint>
                  <sch:rule context="wwp:sp[@who]">
                    <sch:let name="whos" value="tokenize( normalize-space( @who ), ' ')"/>
                    <sch:let name="WHOs" value="for $w in $whos return substring-after( $w,'#')"/>
                    <sch:let name="points2something" value="for $w in $WHOs return exists( id( $w ) )"/>
                    <sch:let name="pointed2by_who" value="for $w in $WHOs return id($w)"/>
                    <sch:report test="$points2something = false()">One or more of the pointers in this @who does not point to a local element.</sch:report>
                    <sch:assert test="count( $pointed2by_who ) eq count( $pointed2by_who[self::wwp:role] )">The @who of ＜sp＞ is supposed to point ＜role＞s, but this one points to: <sch:value-of
                    select="for $e in $pointed2by_who return concat('＜', $e/name(.), '＞ ')"/>.</sch:assert>
                  </sch:rule>
                </constraint>
              </constraintSpec>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="supplied" mode="change">
          <attList>
            <attDef ident="reason" usage="req" mode="replace">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="damaged">
                  <desc>the original page has been damaged through tearing, folding, creasing, foxing, fire or water damage, etc.</desc>
                </valItem>
                <valItem ident="flawed-reproduction">
                  <desc>for cases where the reproduction of the source document causes illegiblity but we have reason to believe the original is still legible (i.e. photocopies with insufficient contrast, smearing, edges cut off during filming, underexposure, etc.)</desc>
                </valItem>
                <valItem ident="obscured">
                  <desc>the original page is intact but the text is illegible due to poorly inked type, patches applied to the original page surface, partial deletion, etc.</desc>
                </valItem>
                <valItem ident="other">
                  <desc>Anything not covered by the above values.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec module="core" ident="date" mode="change">
          <!--
               We want to require a normalization of some sort (e.g.,
               in P4 we required value= on <date>). However, it is
               probably too difficult to express this constraint in
               ODD/RNG because the attributes involved are in
               different classes. The constraint applies to several
               elements, but I'm putting it here as <date> is the most
               frequently occuring element that uses these attributes.
               Also we don't want to require a temporal normalization
               attribute if there is a @prev (because it should be on
               the 1st partial element) or a @calendar (because it may
               not be normalizable). Also, constrain @cert on <date>.
          -->
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <classRef key="model.gLike"/>
              <classRef key="model.phrase"/>
              <classRef key="model.global"/>
            </alternate>
          </content>
          <constraintSpec scheme="schematron" ident="datingAttr">
            <constraint>
              <sch:pattern>
                <sch:rule context="tei:application
                                  |tei:date[not(@prev|@calendar)]
                                  |tei:time[not(@prev|@calendar)]">
                  <sch:assert test="@when or @when-custom or @when-iso or
                                    @notBefore or @notBefore-custom or @notBefore-iso or
                                    @notAfter or @notAfter-iso or @notAfter-custom or
                                    @from or @from-custom or @from-iso or
                                    @to or @to-custom or @to-iso"
                              >At least one temporal normalization attribute should be specified on a ＜<sch:value-of
                                    select="name(.)"/>＞.</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="date_in_docDate">
            <constraint>
              <sch:rule context="tei:docDate/tei:date">
                <sch:let name="dateLen"    value="string-length(normalize-space(.) )"/>
                <sch:let name="docDateLen" value="string-length(normalize-space(..))"/>
                <sch:report test="$docDateLen - $dateLen gt 2" role="warn">Having a date element nested inside a docDate is rarely required</sch:report>
                <sch:report test="$docDateLen - $dateLen le 2" role="error">The date element is not used inside docDate to represent the same date as the docDate — just use the attributes of docDate.</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="cert_on_date" mode="add">
            <constraint>
              <sch:rule context="date/@cert">
                <sch:assert test="parent::publicationStmt">Here at the WWP we only indicate uncertain dates inside the ＜publicationStmt＞.</sch:assert>
                <sch:report test="normalize-space(.) eq 'low'">The value of @cert on ＜date＞ should be "low" (or there should be no @cert).</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <remarks>
            <p>A B.C. date is encoded per ISO 8601:2019 (not ISO
            8601:1988 and thus TEI), which (like the astronomical
            calendar) has a year 0. Thus the year AD 1 (or 1 CE,
            <val>0001</val>) was immediately preceded by the year BC 1
            (or 1 BCE, <val>0000</val>), which was immediately
            preceded by the year BC 2 (or 2 BCE, <val>-0001</val>).
            <egXML xmlns="http://www.tei-c.org/ns/Examples">
              <date when="-1077">1078 B.C.</date>
            </egXML>
            </p>
          </remarks>
        </elementSpec>
        <!-- hand= of <add> is required, but it is in the EXPANSIONS section, as -->
        <!-- its class is changed also. -->
        <elementSpec module="transcr" ident="addSpan" mode="change">
          <attList>
            <attDef ident="hand" mode="change" usage="req"/>
          </attList>
        </elementSpec>
        <classSpec module="linking" type="atts" ident="att.global.linking" mode="change">
          <constraintSpec scheme="schematron" ident="both-next-and-prev">
            <constraint>
              <sch:rule context="*[@xml:id]">
                <sch:let name="isAprev" value="//@prev/normalize-space(.) = concat('#',@xml:id)"/>
                <sch:let name="isAnext" value="//@next/normalize-space(.) = concat('#',@xml:id)"/>
                <sch:report test="@next and not( $isAprev )" sqf:fix="notpreved">Element <sch:value-of select="@xml:id"/> has a next= but is not pointed at by a prev=</sch:report>
                <sch:report test="@prev and not( $isAnext )" sqf:fix="notnexted">Element <sch:value-of select="@xml:id"/> has a prev= but is not pointed at by a next=</sch:report>
                <sch:report test="not( @next ) and $isAprev" sqf:fix="nextless" >Element <sch:value-of select="@xml:id"/> is pointed at by a prev= but does not have a next=</sch:report>
                <sch:report test="not( @prev ) and $isAnext" sqf:fix="prevless" >Element <sch:value-of select="@xml:id"/> is pointed at by a next= but does not have a prev=</sch:report>
              </sch:rule>
              <sqf:fixes>
                <sqf:fix id="notpreved">
                  <sqf:description>
                    <sqf:title>Point at me with a @prev</sqf:title>
                    <sqf:p>Add a @prev that points to me to the element I point to with @next</sqf:p>
                  </sqf:description>
                  <sch:let name="next" value="id( substring(@next,2) )"/>
                  <sch:let name="ptr2me" value="concat('#', @xml:id )"/>
                  <sqf:add target="prev" node-type="attribute" match="$next" select="$ptr2me"/>
                </sqf:fix>
                <sqf:fix id="notnexted">
                  <sqf:description>
                    <sqf:title>Point at me with a @next</sqf:title>
                    <sqf:p>Add a @next that points to me to the element I point to with @prev</sqf:p>
                  </sqf:description>
                  <sch:let name="prev" value="id( substring(@prev,2) )"/>
                  <sch:let name="ptr2me" value="concat('#', @xml:id )"/>
                  <sqf:add target="next" node-type="attribute" match="$prev" select="$ptr2me"/>
                </sqf:fix>
                <sqf:fix id="nextless">
                  <sqf:description>
                    <sqf:title>Add missing @next</sqf:title>
                    <sqf:p>For an element that is pointed to by a @prev but does not have an @next, add the @next</sqf:p>
                  </sqf:description>
                  <sch:let name="myID" value="@xml:id"/>
                  <sqf:add node-type="attribute" target="next" select="concat('#',//*[@prev/normalize-space(.) eq concat('#',$myID)][1]/@xml:id)"/>
                </sqf:fix>
                <sqf:fix id="prevless">
                  <sqf:description>
                    <sqf:title>Add missing @prev</sqf:title>
                    <sqf:p>For an element that is pointed to by a @next but does not have an @prev, add the @prev</sqf:p>
                  </sqf:description>
                  <sch:let name="myID" value="@xml:id"/>
                  <sqf:add node-type="attribute" target="prev" select="concat('#',//*[@next/normalize-space(.) eq concat('#',$myID)][1]/@xml:id)"/>
                </sqf:fix>
              </sqf:fixes>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="next-prev-point-appropriately">
            <constraint>
                <!-- Note: this constraint may not work with
                     `probatron`, but works fine in oXygen. -->
              <sch:rule context="@prev|@next">
                <!-- basics: -->
                <sch:let name="element" value=".."/>
                <sch:let name="me" value="normalize-space(.)"/>
                <sch:let name="ptr" value="if ( starts-with( $me,'#') ) then substring-after( $me,'#') else 'ERROR!?!'"/>
                <!-- tests: -->
                <sch:let name="hasSpace" value="contains( $me,' ')"/>
                <sch:let name="points2local" value="exists( id( $ptr ) )"/>
                <sch:let name="points2same" value="id( $ptr ) is $element"/>
                <sch:let name="points2sameGI" value="name( $element ) eq name( id( $ptr ) )"/>
                <sch:let name="pointsAfter" value="id( $ptr ) &gt;&gt; $element"/>
                <sch:let name="pointsBefore" value="$element &gt;&gt; id( $ptr )"/>
                <!-- message: -->
                <sch:let name="msg_part_1"
                         value="concat(
                                  '@',
                                  name(.),
                                  ' of ＜',
                                  name( $element ),
                                  '＞ ',
                                  if (../@xml:id)
                                    then concat('(with @xml:id &#34;', ../@xml:id,'&#34;)')
                                    else ''
                                )"/>
                <sch:report test="$hasSpace"><sch:value-of select="$msg_part_1"/> has more than 1 pointer (a space in a URI should be written '%20')</sch:report>
                <sch:assert test="if ( not( $hasSpace ) ) then ( $points2local ) else true()"><sch:value-of select="$msg_part_1"/> does not point to a local element.</sch:assert>
                <sch:report test="if ( not( $hasSpace ) ) then ( $points2same ) else false()"><sch:value-of select="$msg_part_1"/> points to itself.</sch:report>
                <sch:assert test="if ( not( $hasSpace ) and $points2local ) then ( $points2sameGI ) else true()"><sch:value-of select="$msg_part_1"/> points to a ＜<sch:value-of select="name( id( $ptr ) )"/>＞ (it should point to another ＜<sch:value-of select="name( $element )"/>＞).</sch:assert>
                <sch:assert test="if ( not( $hasSpace ) and $points2local and local-name(.) eq 'prev' and not( $points2same ) ) then ( $pointsBefore ) else 'true()'"><sch:value-of select="$msg_part_1"/> points to a ＜<sch:value-of select="name( id( $ptr ) )"/>＞ that is after itself.</sch:assert>
                <sch:assert test="if ( not( $hasSpace ) and $points2local and local-name(.) eq 'next' and not( $points2same ) ) then ( $pointsAfter ) else 'true()'"><sch:value-of select="$msg_part_1"/> points to a ＜<sch:value-of select="name( id( $ptr ) )"/>＞ that is prior to itself.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef mode="delete" ident="synch"/>
            <attDef mode="delete" ident="copyOf"/>
            <attDef mode="delete" ident="exclude"/>
            <attDef mode="delete" ident="select"/>
          </attList>
          <remarks><p>The WWP does not use the TEI <att>synch</att>,
            <att>copyOf</att>, <att>exclude</att>, or <att>select</att>
            attributes.</p></remarks>
        </classSpec>
        <!-- No syntactic constraints over vanilla P5, just tighter prose: -->
        <classSpec module="tei" type="atts" ident="att.global.source" mode="change">
          <attList>
            <attDef ident="source" mode="change">
              <remarks xml:lang="en" versionDate="2019-02-27">
                <p>The <att>source</att> attribute points to an
                external source; it provides a pointer to the
                bibliographic citation for the source from which a
                quotation, citation, or passage of direct speech is
                drawn; or a pointer to the complete bibliographic
                entry in our external bibliography that corresponds to
                a transcribed bibliographic citation in a text; or the
                source from which an untranscribably passage encoded
                as <gi>supplied</gi> was obtained. At the WWP this
                means that in general it should point to a
                <gi>bibl</gi>; furthermore that <gi>bibl</gi> is
                usually in XXXX.</p> <?wwp how to describe
                WWPdev/intertextuality/common/bibliography.xml (or
                bibliography-wwo.xml?) here?>
                <p>The location may be provided using any form of URI.
                At the WWP our usual practice is to use a private URI
                scheme by prefixing the <att>xml:id</att> of the
                target <gi>bibl</gi> with a <code>b:</code>.</p>
                <p>If a quotation may have come from more than one
                source, pointers to multiple <gi>bibl</gi>s may be
                provided. E.g. <code>source="b:IT50057 b:IT50059
                b:IT50060"</code>.</p>
                <!-- I don't know how to describe the difference
                     between quote/@ref and quote/@source. —Syd,
                     2019-02-27 -->
              </remarks>
            </attDef>
          </attList>
        </classSpec>

        <!-- ****************************** -->
        <!-- ********* EXPANSIONS ********* -->
        <!-- ****************************** -->
        <!-- Changes in this section need to be in a non-TEI namespace.    -->
        <!-- Since our entire markup language is in our own non-TEI        -->
        <!-- namespace, this doesn't really mean much to us. But most such -->
        <!-- changes are segregated to here in order to make changing this -->
        <!-- to a TEI-conformant customization a bit easier.               -->
        <!-- ************************************************************  -->
        <!-- Explicitly allow use of an <xi:include> instead of <editionStmt> -->
        <elementSpec module="header" ident="fileDesc" mode="change">
          <content>
            <sequence>
              <sequence>
                <elementRef key="titleStmt"/>
                <alternate>
                  <elementRef key="editionStmt" minOccurs="1" maxOccurs="1"/>
                  <elementRef key="include" minOccurs="1" maxOccurs="1"/>
                </alternate>
                <elementRef key="extent" minOccurs="0"/>
                <elementRef key="publicationStmt"/>
                <elementRef key="seriesStmt" minOccurs="0"/>
                <elementRef key="notesStmt" minOccurs="0"/>
              </sequence>
              <elementRef key="sourceDesc" minOccurs="1" maxOccurs="unbounded"/>
            </sequence>
          </content>
        </elementSpec>
        <!-- We permit <add> anywhere. Note that we have also required hand= -->
        <elementSpec module="core" ident="add" mode="change">
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.global"/>
            <memberOf key="att.transcriptional"/>
            <memberOf key="att.placement"/>
            <memberOf key="att.typed"/>
          </classes>
          <attList>
            <attDef ident="hand" mode="change" usage="req"/>
          </attList>
        </elementSpec>
        <!-- Our main change to <div> is attribute constraint. But it is in this -->
        <!-- section because we also change the content model to allow members of -->
        <!-- model.divBottom to occur whether or not an element from the "main" -->
        <!-- section of the content model has occured. However, we do want to make -->
        <!-- sure there is at least *something* in a <div> -->
        <elementSpec module="textstructure" ident="div" mode="change">
          <classes mode="change">
            <!--
                 <memberOf key="att.global"/>
                 <memberOf key="att.divLike"/>
                 <memberOf key="att.typed"/>
                 <memberOf key="att.declaring"/>
                 <memberOf key="model.divLike"/>
            -->
            <memberOf key="att.typed" mode="delete"/>
            <memberOf key="att.structuralCategorization"/>
          </classes>
          <content>
            <sequence>
              <alternate minOccurs="0" maxOccurs="unbounded">
                <classRef key="model.divTop"/>
                <classRef key="model.global"/>
              </alternate>
              <alternate minOccurs="0">
                <sequence minOccurs="1" maxOccurs="unbounded">
                  <alternate>
                    <classRef key="model.divLike"/>
                    <classRef key="model.divGenLike"/>
                  </alternate>
                  <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                </sequence>
                <sequence>
                  <sequence minOccurs="1" maxOccurs="unbounded">
                    <!--here only for DTD generation-->
                    <classRef key="model.common"/>
                    <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                  </sequence>
                  <sequence minOccurs="0" maxOccurs="unbounded">
                    <alternate>
                      <classRef key="model.divLike"/>
                      <classRef key="model.divGenLike"/>
                    </alternate>
                    <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                  </sequence>
                </sequence>
              </alternate>
              <sequence minOccurs="0" maxOccurs="unbounded">
                <!--here only for DTD generation-->
                <classRef key="model.divBottom"/>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
            </sequence>
          </content>
          <constraintSpec scheme="schematron" ident="something_in_div">
            <constraint>
              <sch:pattern>
                <sch:rule context="tei:div">
                  <sch:assert test="descendant::tei:div or
                                    descendant::tei:l[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:ab[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:p[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:floatingText[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:lg[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:sp[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:bibl[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:biblFull or
                                    descendant::tei:biblStruct[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:list[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:listBibl[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:table[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:listEvent or
                                    descendant::tei:quote[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:stage[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:castList[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:gap[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:join or
                                    descendant::tei:joinGrp or
                                    descendant::wwp:advertisement[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:note[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:figure[ not( ancestor::tei:epigraph )] or
                                    descendant::wwp:unknown[ not( ancestor::tei:epigraph )] or
                                    descendant::tei:trailer or
                                    descendant::wwp:elision[ not( ancestor::tei:epigraph )]">&lt;<sch:name/>&gt; with no significant content (i.e., none of: ab advertisement bibl biblFull biblStruct castList div elision figure floatingText gap join joinGrp l lg list listBibl listEvent note p quote sp stage trailer unknown)</sch:assert>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="avoid_model.divTop_in_middle">
            <desc>When a <gi>div</gi> has no children from <name
            type="class">model.common</name> or nested <gi>div</gi>s
            (i.e., all children are from <name
            type="class">model.divTop</name> or <name
            type="class">model.global</name>) — which happens, e.g.,
            when the main content of the <gi>div</gi> is a serios of
            <gi>advertisement</gi>s — we would like to ensure there
            are no <name type="class">model.divTop</name> elements in
            the middle.</desc>
            <constraint>
              <sch:rule context="wwp:div">
                <!-- Note: the _self versions of the variables below
                     are not currently used, in large part because it
                     seems such a variable inside a predicate does not
                     work. But I put some effort into making them and
                     getting them to line up nicely, so I did not have
                     the hear to delete them. -->
                <sch:let name="model.divTop_self"  value="self::wwp:argument  |  self::wwp:dateline |  self::wwp:desc |  self::wwp:docDate |  self::wwp:docRole |  self::wwp:epigraph |  self::wwp:head |  self::wwp:label |  self::wwp:opener |  self::wwp:respLine"/>
                <sch:let name="model.divTop_child" value="child::wwp:argument | child::wwp:dateline | child::wwp:desc | child::wwp:docDate | child::wwp:docRole | child::wwp:epigraph | child::wwp:head | child::wwp:label | child::wwp:opener | child::wwp:respLine"/>
                <sch:let name="model.global_self"  value="self::wwp:add  |  self::wwp:addSpan |  self::wwp:advertisement |  self::wwp:alt |  self::wwp:anchor |  self::wwp:cb |  self::wwp:damageSpan |  self::wwp:delSpan |  self::wwp:elision |  self::wwp:figure |  self::wwp:gap |  self::wwp:lb |  self::wwp:link |  self::wwp:listTranspose |  self::wwp:metamark |  self::wwp:milestone |  self::wwp:mw |  self::wwp:note |  self::wwp:pb |  self::wwp:space |  self::wwp:substJoin |  self::wwp:unknown"/>
                <sch:let name="model.global_child" value="child::wwp:add | child::wwp:addSpan | child::wwp:advertisement | child::wwp:alt | child::wwp:anchor | child::wwp:cb | child::wwp:damageSpan | child::wwp:delSpan | child::wwp:elision | child::wwp:figure | child::wwp:gap | child::wwp:lb | child::wwp:link | child::wwp:listTranspose | child::wwp:metamark | child::wwp:milestone | child::wwp:mw | child::wwp:note | child::wwp:pb | child::wwp:space | child::wwp:substJoin | child::wwp:unknown"/>
                <sch:let name="model.common_self"  value="self::wwp:ab  |  self::wwp:bibl |  self::wwp:biblStruct |  self::wwp:castList |  self::wwp:desc |  self::wwp:floatingText |  self::wwp:l |  self::wwp:label |  self::wwp:lg |  self::wwp:list |  self::wwp:listBibl |  self::wwp:p |  self::wwp:q |  self::wwp:quote |  self::wwp:said |  self::wwp:sp |  self::wwp:spGrp |  self::wwp:stage |  self::wwp:table"/>
                <sch:let name="model.common_child" value="child::wwp:ab | child::wwp:bibl | child::wwp:biblStruct | child::wwp:castList | child::wwp:desc | child::wwp:floatingText | child::wwp:l | child::wwp:label | child::wwp:lg | child::wwp:list | child::wwp:listBibl | child::wwp:p | child::wwp:q | child::wwp:quote | child::wwp:said | child::wwp:sp | child::wwp:spGrp | child::wwp:stage | child::wwp:table"/>
                <sch:report test="( not( child::wwp:div | $model.common_child ) ) and ( $model.divTop_child )[last()]/preceding-sibling::*[ self::wwp:add |  self::wwp:addSpan |  self::wwp:advertisement |  self::wwp:alt |  self::wwp:anchor |  self::wwp:cb |  self::wwp:damageSpan |  self::wwp:delSpan |  self::wwp:elision |  self::wwp:figure |  self::wwp:gap |  self::wwp:lb |  self::wwp:link |  self::wwp:listTranspose |  self::wwp:metamark |  self::wwp:milestone |  self::wwp:mw |  self::wwp:note |  self::wwp:pb |  self::wwp:space |  self::wwp:substJoin |  self::wwp:unknown ]">This ＜div＞ seems to have a divTop element (e.g. ＜head＞) in the middle</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>         
        </elementSpec>
        <!-- <imprimatur> is here because we allow it in model.frontPart, -->
        <!-- which it is not a member of in vanilla TEI; we also permit   -->
        <!-- <docRole> to occur as a child. -->
        <elementSpec module="textstructure" ident="imprimatur" mode="change">
          <classes mode="change">
            <memberOf key="model.frontPart"/>
          </classes>
          <content>
            <alternate minOccurs="1" maxOccurs="unbounded">
              <macroRef key="macro.paraContent"/>
              <elementRef key="docAuthor"/>
            </alternate>
          </content>
        </elementSpec>
        <!-- Add type= to <resp> -->
        <elementSpec module="core" ident="resp" mode="change">
          <attList>
            <attDef mode="add" ident="type">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="author">
                  <desc>See corresponding @type value on docAuthor.</desc>
                </valItem>
                <valItem ident="author-secondary">
                  <desc>a person or organization credited as an author, but given lower precedence than the main author(s)</desc>
                </valItem>
                <valItem ident="bookseller">
                  <desc>See corresponding @type value on docAuthor.</desc>
                </valItem>
                <valItem ident="printer">
                  <desc>See corresponding @type value on docAuthor.</desc>
                </valItem>
                <valItem ident="translator">
                  <desc>See corresponding @type value on docAuthor.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <!-- Add cit= and ref= to <quote> -->
        <elementSpec module="core" ident="quote" mode="change">
          <content>
            <classRef key="macro.specialPara"/>
          </content>
          <constraintSpec scheme="schematron" ident="quotation_cit">
            <constraint>
              <sch:pattern>
                <sch:rule context="wwp:quote[ starts-with( @cit,'#' ) ]">
                  <sch:assert test="//wwp:bibl[ @xml:id eq substring-after( current()/@cit,'#' ) ]">cit= attribute of ＜<sch:name/>＞ does not point to a ＜bibl＞.</sch:assert>
                </sch:rule>
                <sch:rule context="wwp:quote[ contains(@cit,'#') ]">
                  <sch:assert test="document( substring-before( @cit,'#') )//wwp:bibl[ @xml:id = substring-after( current()/@cit,'#') ]">cit= attribute of ＜<sch:name/>＞ does not point to a ＜bibl＞.</sch:assert>
                </sch:rule>
                <sch:rule context="wwp:quote[ @cit ]">
                  <sch:report test="not( contains( @cit,'#') )">cit= attribute of ＜<sch:name/>＞ must point to particular ＜bibl＞ element via its xml:id=</sch:report>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <!-- 
               Look to version 5.46.2, revision 36782 for our just
               deleted definition of and constraints on the quote/@ref
               attribute (used to point to a <bibl>, <biblStruct>, or
               <biblFull> in the bibliography file).
          -->
          <attList>
            <attDef ident="cit" mode="add" usage="opt">
              <gloss>prose citation reference</gloss>
              <desc>points to (one or more) bibliographic citation(s)
              for this quotation as they appear in the source</desc>
              <datatype minOccurs="1" maxOccurs="unbounded"><dataRef key="teidata.pointer"/></datatype>
              <remarks>
                <p>At the current time we do not use this attribute;
                we may, however, use it in the future.</p>
              </remarks>
            </attDef>
            <attDef ident="type" mode="replace" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="adaptation">
                  <desc>the quoted material is changed from its original
                    context in a deliberate way, possibly to fit into the text</desc>
                </valItem>
                <valItem ident="parody">
                  <desc>the quotation is significantly different from the
                    original text, and appears to be a deliberate parody</desc>
                </valItem>
                <valItem ident="remix">
                  <desc>the quoted material has been re-ordered or
                  otherwise significantly modified from the original
                  in a deliberate fashion (other than a paraphrase or
                  parody)</desc>
                </valItem>
                <valItem ident="undetermined">
                  <desc>as of yet undeterminted</desc>
                </valItem>
              </valList>
              <remarks>
                <p>Paraphrases may have changes to the quotation that
                are deliberate or necessary because of how it fits
                into the text.</p>
              </remarks>
            </attDef>
          </attList>
        </elementSpec>
        <!-- We prefer the P4 content of <editorialDecl>, which permitted <p>s at -->
        <!-- the end of the set of specialized elements -->
        <elementSpec module="header" ident="editorialDecl" mode="change">
          <content>
            <alternate>
              <sequence>
                <classRef key="model.editorialDeclPart" minOccurs="1" maxOccurs="unbounded"/>
                <classRef key="model.pLike" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
              <classRef key="model.pLike" minOccurs="1" maxOccurs="unbounded"/>
            </alternate>
          </content>
        </elementSpec>
        <!-- Our added <regMe> element -->
        <elementSpec ident="regMe" mode="add">
          <gloss>regularize me</gloss>
          <desc>Canonical abbreviation, citation, or reference flagged
          for automated regularization.</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.pPart.transcriptional"/>
            <memberOf key="att.canonical"/>
          </classes>
          <content>
            <macroRef key="macro.phraseSeq"/>
          </content>
          <remarks>
            <p>Used as a temporary replacement for a <gi>choice</gi>
            element with the content of this <gi>regMe</gi> as the
            content of a child <gi>reg</gi>, with an automatically
            created sibling <gi>orig</gi>.</p>
          </remarks>
        </elementSpec>
        <!-- Our added <format> element -->
        <elementSpec ident="format" mode="add">
          <desc>contains the named format of a printed item</desc>
          <!-- not a member of any model class; included directly -->
          <!-- in possible content of <dimensions> -->
          <content>
            <!-- dataRef key="teidata.enumerated"/ -->
            <!-- Using RELAX NG, as a <valList> is not processed correctly; see -->
            <!-- https://github.com/TEIC/Stylesheets/issues/154.                -->
            <rng:choice>
              <rng:value>broadsheet</rng:value>
              <rng:value>duodecimo</rng:value>
              <rng:value>folio</rng:value>
              <rng:value>half-sheet</rng:value>
              <rng:value>octavo</rng:value>
              <rng:value>quarto</rng:value>
              <rng:value>unknown</rng:value>
            </rng:choice>
            <!-- valList type="closed">
              <valItem ident="broadsheet">
                <desc>a long sheet of paper, unfolded, on which one side has been printed</desc>
              </valItem>
              <valItem ident="duodecimo">
                <desc>a document with twelve leaves, either folded uncut or folded in two sections after one cut</desc>
              </valItem>
              <valItem ident="folio">
                <desc>a long sheet of paper, folded once to make four leaves</desc>
              </valItem>
              <valItem ident="half-sheet">
                <desc>a sheet of paper, half the size of a broadsheet</desc>
              </valItem>
              <valItem ident="octavo">
                <desc>a document with sixteen leaves</desc>
              </valItem>
              <valItem ident="quarto">
                <desc>a document with eight leaves</desc>
              </valItem>
              <valItem ident="unknown">
                <desc>the format is unknown or cannot be ascertained</desc>
              </valItem>
            </valList -->
          </content>
        </elementSpec>
        <!-- our added <format> element is permitted inside <dimensions> as an -->
        <!-- alternative to height, width, and depth -->
        <elementSpec module="msdescription" ident="dimensions" mode="change">
          <content>
            <alternate>
              <elementRef key="format"/>
              <sequence>
                <elementRef key="height"/>
                <elementRef key="width" minOccurs="0"/>
                <elementRef key="depth" minOccurs="0"/>
              </sequence>
              <sequence>
                <elementRef key="width"/>
                <elementRef key="depth" minOccurs="0"/>
              </sequence>
              <elementRef key="depth"/>
            </alternate>
          </content>
        </elementSpec>
        <!-- WWP permits <docRole> and <docSale> in <docImprint> -->
        <elementSpec module="textstructure" ident="docImprint" mode="change">
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <classRef key="model.gLike"/>
              <classRef key="model.phrase"/>
              <elementRef key="pubPlace"/>
              <elementRef key="docDate"/>
              <elementRef key="publisher"/>
              <elementRef key="docAuthor"/>       <!-- aka <docRole> -->
              <elementRef key="docSale"/>
              <classRef key="model.global"/>
            </alternate>
          </content>
        </elementSpec>
        <!-- WWP permits <epigraph> inside <bibl> -->
        <elementSpec module="core" ident="bibl" mode="change">
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <textNode/>
              <classRef key="model.gLike"/>
              <classRef key="model.highlighted"/>
              <classRef key="model.pPart.data"/>
              <classRef key="model.pPart.edit"/>
              <classRef key="model.segLike"/>
              <classRef key="model.ptrLike"/>
              <classRef key="model.biblPart"/>
              <classRef key="model.global"/>
              <elementRef key="epigraph"/>
            </alternate>
          </content>
        </elementSpec>
        <!-- add type= to <author> -->
        <elementSpec module="core" ident="author" mode="change">
          <classes mode="change">
            <memberOf key="model.phrase"/>
          </classes>
          <constraintSpec ident="authors-have-refs-in-metadata" scheme="schematron">
            <constraint>
              <sch:rule context="wwp:teiHeader//wwp:author/wwp:persName">
                <sch:assert test="@ref">Authors should have a reference to the personography.</sch:assert>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef mode="add" ident="type" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <defaultVal>main</defaultVal>
              <valList mode="add" type="closed">
                <valItem ident="main">
                  <desc>a primary author.</desc>
                </valItem>
                <valItem ident="other">
                  <desc>an author whom the Women Writers Project for some reason wishes to consider as occupying a subsidiary role.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <!-- add type= to <catRef> -->
        <elementSpec module="header" ident="catRef" mode="change">
          <attList>
            <attDef mode="add" ident="type" usage="opt">
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <defaultVal>main</defaultVal>
              <valList mode="add" type="closed">
                <valItem ident="main">
                  <desc>the primary classification of a text's genre. There
                    should only be one <gi>catRef</gi> with this type per
                    textfile.</desc>
                </valItem>
                <valItem ident="other">
                  <desc>a classification of a text's genre, but not the single
                    most important classification.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <!-- add type= to <sic> -->
        <elementSpec module="core" ident="sic" mode="change">
          <constraintSpec scheme="schematron" ident="no_correction_of_erroneous_metawork">
            <constraint>
              <sch:rule context="wwp:sic[@type eq 'metawork']">
                <sch:report test="parent::wwp:choice or (preceding-sibling::*[1]|following-sibling::*[1])[self::wwp:corr]">At the WWP we do not correct metawork errors</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <constraintSpec scheme="schematron" ident="no_content_in_erroneous_metawork_flag">
            <constraint>
              <sch:rule context="wwp:sic[@type eq 'metawork']">
                <sch:report test=".//* | .//text()[ normalize-space(.) != '']">Metawork error flags should not have content</sch:report>
              </sch:rule>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="type">
              <valList type="closed">
                <valItem ident="metawork">
                  <desc>used (on an empty <gi>sic</gi> w/o a
                  <gi>choice</gi> parent) to indicate a missing piece
                  of metawork</desc>
                </valItem>
                <valItem ident="seq">
                  <gloss>sequencing</gloss>
                  <desc>the error represents an error in the
                  sequencing of some countable feature, e.g. pages or
                  list items.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </elementSpec>
        <!-- add target= to <item>, but only for reference lists
             (including indeces and TOCs); also allow a child
             <argument> -->
        <elementSpec module="core" ident="item" mode="change">
          <content>
            <alternate minOccurs="0" maxOccurs="unbounded">
              <elementRef key="argument"/>
              <macroRef key="macro.specialPara"/>
            </alternate>
          </content>
          <constraintSpec scheme="schematron" ident="non-reference-lists-do-not-point">
            <constraint>
              <sch:pattern>
                <sch:rule context="wwp:list[ not( @type = ('toc', 'reference', 'index' ) ) ]">
                  <sch:report test="child::wwp:item/@target">＜item＞ elements should only have target= attributes if the list is a table of contents, index, or other reference list</sch:report>
                </sch:rule>
              </sch:pattern>
            </constraint>
          </constraintSpec>
          <attList>
            <attDef ident="target" usage="rec" mode="add">
              <desc>indicates the portion of the content to which this
              entry in the table of contents, index, or other
              reference list refers.</desc>
              <datatype maxOccurs="unbounded"><dataRef key="teidata.pointer"/></datatype>
              <constraintSpec scheme="schematron" ident="items-point-internally">
                <constraint>
                  <sch:assert test="id( substring( normalize-space( . ), 2 ) )">The @target attribute of an ＜item＞ in a "toc", "reference", or "index" list should point to an element in the same document.</sch:assert>
                </constraint>
              </constraintSpec>
              <valDesc>reference to the <att>xml:id</att>s of
              element(s) to which this entry refers.</valDesc>
              <remarks>
                <p>For tables of contents, typically points to to a
                chapter, act, or poem encoded with a <gi>div</gi>. For
                indices may point to somewhat smaller chunks of text.
                If there are not already elements at the appropriate
                location, then generic <gi>anchor</gi> or <gi>seg</gi>
                elements must inserted and given <att>xml:id</att>
                values to be pointed at.</p>
                <p>If the passage to be pointed at overlaps existing
                encoded logical structures, it should be encoded using
                multiple <gi>seg</gi> elements which should be pointed
                at with a <gi>join</gi> to which the <att>target</att>
                of <gi>item</gi> can point.</p>
              </remarks>
            </attDef>
          </attList>
          <remarks>
            <p>The WWP-added attribute <att>target</att> is only
            permitted an an <gi>item</gi> whose parent <gi>list</gi>
            has a <att>type</att> of <val>toc</val>,
            <val>reference</val>, or <val>index</val>.</p>
          </remarks>
        </elementSpec>
        <elementSpec ident="role" module="core" mode="change">
          <attList>
            <attDef ident="gender" mode="add">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="wwpdata.sex"/>
              </datatype>
              <valDesc>If not specified, the value should be
              considered <val>unknown</val> unless there is a
              <att>gender</att> on an ancestor, in which case the
              closest such value is used. <emph>Exception</emph>: when
              that closest ancestor <att>gender</att> is
              <val>mixed</val>, the value here is still considered
              <val>unknown</val>.</valDesc>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="castItem" module="drama" mode="change">
          <attList>
            <attDef ident="gender" mode="add">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="wwpdata.sex"/>
              </datatype>
              <valDesc>If not specified, the value should be
              considered <val>unknown</val> unless there is a
              <att>gender</att> on an ancestor, in which case the
              closest such value is used. <emph>Exception</emph>: when
              that closest ancestor <att>gender</att> is
              <val>mixed</val>, the value here is still considered
              <val>unknown</val>.</valDesc>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="castGroup" module="drama" mode="change">
          <attList>
            <attDef ident="gender" mode="add">
              <datatype minOccurs="1" maxOccurs="1">
                <dataRef key="wwpdata.sex"/>
              </datatype>
            </attDef>
          </attList>
        </elementSpec>
        <!-- ***************************** -->
        <!-- class manipulation subsection -->
        <!-- ***************************** -->
        <classSpec ident="model.labelLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.noteTop"/>
            <memberOf key="model.divTop"/>
            <memberOf key="model.castItemPart"/>
          </classes>
        </classSpec>
        <!-- Add new @author attribute to att.declaring class, as it is sort of a  -->
        <!-- shorthand for "different metadata applies to me", and add <postsript> -->
        <!-- as a member of this class. -->
        <classSpec ident="att.declaring" type="atts" mode="change">
          <attList>
            <attDef ident="author" mode="add" usage="opt">
              <datatype minOccurs="1" maxOccurs="7">
                <dataRef key="teidata.pointer"/>
              </datatype>
              <valList type="semi">
                <valItem ident="p:tbd-female">
                  <gloss>to be determined, female</gloss>
                  <desc>We are confident this author is a woman, but
                  have yet to figure out exactly who she is.</desc>
                </valItem>
                <valItem ident="p:tbd-male">
                  <gloss>to be determined, male</gloss>
                  <desc>We are confident this author is a man, but
                  have yet to figure out exactly who he is.</desc>
                </valItem>
                <valItem ident="p:tbd">
                  <gloss>to be determined</gloss>
                  <desc>We do not know who this author is, but expect
                  (or at least hope) to find out in the near future.</desc>
                </valItem>
                <valItem ident="p:unknown-female">
                  <desc>We do not know who this author is, but are
                  reasonably confident she is a woman. While it is
                  possible her identity is ascertained in the future,
                  we are not expecting it.</desc>
                </valItem>
                <valItem ident="p:unknown-male">
                  <desc>We do not know who this author is, but are
                  reasonably confident he is a man. While it is
                  possible his identity is ascertained in the future,
                  we are not expecting it.</desc>
                </valItem>
                <valItem ident="p:unknown.zzx">
                  <desc>We do not know how this author is. While it is
                  possible his or her identity is ascertained in the
                  future, we are not expecting it.</desc>
                </valItem>
                <valItem ident="p:collective">
                  <desc>Used to indicate that authorship is attributed
                  to a collection of individuals, sex
                  unspecified.</desc>
                </valItem>
              </valList>
              <remarks>
                <p>Should point to one or more &lt;person> elements
                from our personography, preferably using the
                <code>p:</code> prefix.</p>
              </remarks>
            </attDef>
          </attList>
        </classSpec>
        <!-- ******************** -->
        <!-- new class subsection -->
        <!-- ******************** -->
        <classSpec ident="model.hyperDivPart" type="model" mode="add" generate="sequenceOptional">
          <desc>groups together elements that may appear inside the
          <gi>hyperDiv</gi>.</desc>
        </classSpec>
        <classSpec ident="model.noteTop" type="model" mode="add">
          <desc>groups together elements that may appear at the top of
          a <gi>note</gi> or <gi>postscript</gi>.</desc>
        </classSpec>
        <classSpec ident="model.notePart" type="model" mode="add">
          <desc>groups together components of a <gi>note</gi>,
          <gi>gloss</gi>, or <gi>postscript</gi>.</desc>
        </classSpec>
        <classSpec ident="model.noteBottom" type="model" mode="add">
          <desc>groups together elements that may appear at the bottom
          of a <gi>note</gi> or <gi>postscript</gi>.</desc>
        </classSpec>
        <classSpec ident="model.headLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.noteTop"/>
          </classes>
        </classSpec>
        <elementSpec ident="opener" module="textstructure" mode="change">
          <classes mode="change">
            <memberOf key="model.noteTop"/>
          </classes>
        </elementSpec>
        <classSpec ident="model.biblLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <classSpec ident="model.divPart" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <classSpec ident="model.attributable" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <classSpec ident="model.qLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <classSpec ident="model.listLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <classSpec ident="model.segLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <classSpec ident="model.stageLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <elementSpec ident="castList" module="drama" mode="change">
          <classes mode="change">
            <memberOf key="model.hyperDivPart"/>
            <memberOf key="model.notePart"/>
          </classes>
        </elementSpec>
        <classSpec ident="model.noteLike" type="model" mode="change">
          <classes mode="change">
            <memberOf key="model.notePart"/>
          </classes>
        </classSpec>
        <elementSpec ident="closer" module="core" mode="change">
          <classes mode="change">
            <memberOf key="model.noteBottom"/>
          </classes>
        </elementSpec>
        <elementSpec ident="trailer" module="core" mode="change">
          <classes mode="change">
            <memberOf key="model.noteBottom"/>
          </classes>
        </elementSpec>

        <!-- ********************** -->
        <!-- macro addition section -->
        <!-- ********************** -->
        <!-- We refer to this complicated content model more than once, so I've -->
        <!-- factored it out into a macro for ease of modification. It is used -->
        <!-- in <note> and <postscript>. -->
        <macroSpec ident="macro.noteContent" mode="add">
          <content>
            <alternate>
              <sequence>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                <sequence>
                  <sequence minOccurs="0" maxOccurs="unbounded">
                    <classRef key="model.noteTop"/>
                    <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                  </sequence>
                  <sequence>
                    <sequence minOccurs="1" maxOccurs="unbounded">
                      <classRef key="model.notePart"/>
                      <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                    <sequence minOccurs="0" maxOccurs="unbounded">
                      <classRef key="model.noteBottom"/>
                      <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
                    </sequence>
                  </sequence>
                </sequence>
              </sequence>
              <sequence minOccurs="1" maxOccurs="unbounded">
                <elementRef key="byline"/>
                <classRef key="model.global" minOccurs="0" maxOccurs="unbounded"/>
              </sequence>
            </alternate>
          </content>
        </macroSpec>

        <!-- ***************************************************** -->
        <!-- stuff leftover from EMPB that I still need to look at -->
        <!-- ***************************************************** -->
        <classSpec module="tei" type="atts" ident="att.authorialIntervention" mode="change">
          <attList>
            <!-- ********* status= ********* -->
            <attDef ident="status" usage="opt" mode="replace">
              <desc>may be used to indicate faulty deletions, e.g. strikeouts which include too much
              or too little text, or erroneous additions, e.g., an insertion which duplicates some
              of the text already present.</desc>
              <datatype><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed">
                <valItem ident="duplicate">
                  <desc>all of the text indicated as an addition duplicates some text that is in the
                  original, whether the duplication is word-for-word or less exact.</desc>
                </valItem>
                <valItem ident="duplicate-partial">
                  <desc>part of the text indicated as an addition duplicates some text that is in
                  the original</desc>
                </valItem>
                <valItem ident="excessStart">
                  <desc>some text at the beginning of the deletion is marked as deleted even though
                  it clearly should not be deleted.</desc>
                </valItem>
                <valItem ident="excessEnd">
                  <desc>some text at the end of the deletion is marked as deleted even though it
                  clearly should not be deleted.</desc>
                </valItem>
                <valItem ident="shortStart">
                  <desc>some text at the beginning of the deletion is not marked as deleted even
                  though it clearly should be.</desc>
                </valItem>
                <valItem ident="shortEnd">
                  <desc>some text at the end of the deletion is not marked as deleted even though it
                  clearly should be.</desc>
                </valItem>
                <valItem ident="unremarkable">
                  <desc>the deletion is not faulty.</desc>
                </valItem>
              </valList>
              <remarks>
                <p>Status information on each deletion is needed rather rarely except in critical
                editions from authorial manuscripts; status information on additions is even less
                common.</p>
                <p>Marking a deletion or addition as faulty is inescapably an interpretive act; the
                usual test applied in practice is the linguistic acceptability of the text with
                and without the letters or words in question.</p>
              </remarks>
            </attDef>
            <!-- ********* type= ********* -->
            <attDef ident="type" usage="opt" mode="delete"/>
          </attList>
        </classSpec>
        <classSpec ident="att.measured" mode="change" module="tei" type="atts">
          <attList>
            <attDef ident="unit" mode="change">
              <desc>names the units used for the measurement.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed" mode="replace">
                <valItem ident="cm">
                  <gloss>centimetres</gloss>
                </valItem>
                <valItem ident="mm">
                  <gloss>millimetres</gloss>
                </valItem>
                <valItem ident="in">
                  <gloss>inches</gloss>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="scope" mode="change">
              <desc>specifies the applicability of this measurement, where&#xD; more than one
              object is being measured.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed" mode="replace">
                <valItem ident="all">
                  <desc>measurement applies to all instances.</desc>
                </valItem>
                <valItem ident="most">
                  <desc>measurement applies to most of the instances inspected.</desc>
                </valItem>
                <valItem ident="range">
                  <desc>measurement applies to only the specified range of instances.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.measurement" mode="change" module="tei" type="atts">
          <attList>
            <attDef ident="unit" mode="change">
              <desc>indicates the units used for the measurement, usually&#xD; using the
              standard symbol for the desired units.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed" mode="replace">
                <valItem ident="page">
                  <desc>leaves</desc>
                </valItem>
                <!-- base SI units -->
                <valItem ident="m">
                  <gloss>metre</gloss>
                  <desc>SI base unit of length</desc>
                </valItem>
                <valItem ident="kg">
                  <gloss>kilogram</gloss>
                  <desc>SI base unit of mass</desc>
                </valItem>
                <valItem ident="s">
                  <gloss>second</gloss>
                  <desc>SI base unit of time</desc>
                </valItem>
                <valItem ident="A">
                  <gloss>ampere</gloss>
                  <desc>SI base unit of electric current</desc>
                </valItem>
                <valItem ident="K">
                  <gloss>kelvin</gloss>
                  <desc>SI base unit of thermodynamic temperature</desc>
                </valItem>
                <valItem ident="mol">
                  <gloss>mole</gloss>
                  <desc>SI base unit of amount of substance</desc>
                </valItem>
                <valItem ident="cd">
                  <gloss>candela</gloss>
                  <desc>SI base unit of luminous intensity</desc>
                </valItem>
                <!-- SI derived units that have separate symbols -->
                <valItem ident="rad">
                  <gloss>radian</gloss>
                  <desc>SI unit of plane angle</desc>
                </valItem>
                <valItem ident="sr">
                  <gloss>steradian</gloss>
                  <desc>SI unit of solid angle</desc>
                </valItem>
                <valItem ident="Hz">
                  <gloss>hertz</gloss>
                  <desc>SI unit of frequency</desc>
                </valItem>
                <valItem ident="N">
                  <gloss>newton</gloss>
                  <desc>SI unit of force</desc>
                </valItem>
                <valItem ident="Pa">
                  <gloss>pascal</gloss>
                  <desc>SI unit of pressure or stress</desc>
                </valItem>
                <valItem ident="J">
                  <gloss>joule</gloss>
                  <desc>SI unit of energy or work</desc>
                </valItem>
                <valItem ident="W">
                  <gloss>watt</gloss>
                  <desc>SI unit of power or radiant flux</desc>
                </valItem>
                <valItem ident="C">
                  <gloss>coulomb</gloss>
                  <desc>SI unit of electric charge or quantity of electricity</desc>
                </valItem>
                <valItem ident="V">
                  <gloss>volt</gloss>
                  <desc>SI unit of electric potential difference or electromotive force</desc>
                </valItem>
                <valItem ident="F">
                  <gloss>farad</gloss>
                  <desc>SI unit of capacitance</desc>
                </valItem>
                <valItem ident="Ω">
                  <gloss>ohm</gloss>
                  <desc>SI unit of electric resistance</desc>
                </valItem>
                <valItem ident="S">
                  <gloss>siemens</gloss>
                  <desc>SI unit of electric conductance</desc>
                </valItem>
                <valItem ident="Wb">
                  <gloss>weber</gloss>
                  <desc>SI unit of magnetic flux</desc>
                </valItem>
                <valItem ident="T">
                  <gloss>tesla</gloss>
                  <desc>SI unit of magnetic flux density</desc>
                </valItem>
                <valItem ident="H">
                  <gloss>henry</gloss>
                  <desc>SI unit of inductance</desc>
                </valItem>
                <valItem ident="℃">
                  <gloss>degree Celsius</gloss>
                  <desc>SI unit of Celsius temperature</desc>
                </valItem>
                <valItem ident="lm">
                  <gloss>lumen</gloss>
                  <desc>SI unit of luminous flux</desc>
                </valItem>
                <valItem ident="lx">
                  <gloss>lux</gloss>
                  <desc>SI unit of illuminance</desc>
                </valItem>
                <valItem ident="Bq">
                  <gloss>becquerel</gloss>
                  <desc>SI unit of activity (referred to a radionuclide</desc>
                </valItem>
                <valItem ident="Gy">
                  <gloss>gray</gloss>
                  <desc>SI unit of absorbed dose or specific energy (imparted)</desc>
                </valItem>
                <valItem ident="Sv">
                  <gloss>sievert</gloss>
                  <desc>SI unit of dose equivalent, ambient dose equivalent, directional dose
                  equivalent, personal dose equivalent, or organ equivalent dose</desc>
                </valItem>
                <!-- selected non-SI units accepted for use with the International System -->
                <valItem ident="min">
                  <gloss>minute</gloss>
                  <desc>60 s</desc>
                </valItem>
                <valItem ident="h">
                  <gloss>hour</gloss>
                  <desc>3600 s</desc>
                </valItem>
                <valItem ident="d">
                  <gloss>day</gloss>
                  <desc>86 400 s</desc>
                </valItem>
                <valItem ident="°">
                  <gloss>degree</gloss>
                </valItem>
                <valItem ident="′">
                  <gloss>minute</gloss>
                </valItem>
                <valItem ident="″">
                  <gloss>second</gloss>
                </valItem>
                <valItem ident="L">
                  <gloss>litre</gloss>
                  <desc>1 dm³</desc>
                </valItem>
                <valItem ident="t">
                  <gloss>tonne</gloss>
                  <desc>10³ kg</desc>
                </valItem>
                <valItem ident="bel">
                  <gloss>bel</gloss>
                  <desc>values of (base 10) logarithmic quantities including sound pressure
                  level</desc>
                </valItem>
                <valItem ident="Np">
                  <gloss>neper</gloss>
                  <desc>similar to the bel, but uses natural logarithms</desc>
                </valItem>
                <valItem ident="eV">
                  <gloss>electron volt</gloss>
                  <desc>~1.6×10⁻¹⁹ J</desc>
                </valItem>
                <valItem ident="u">
                  <gloss>unified atomic mass unit</gloss>
                  <desc>a Dalton, or Da; ~1.7×10⁻²⁷
                  kg</desc>
                </valItem>
                <valItem ident="ua">
                  <gloss>atronomical unit</gloss>
                  <desc>~1.5×10¹¹ m</desc>
                </valItem>
                <valItem ident="a">
                  <gloss>are</gloss>
                  <desc>1 dam²</desc>
                </valItem>
                <valItem ident="ha">
                  <gloss>hectare</gloss>
                  <desc>1 hm²</desc>
                </valItem>
                <valItem ident="bar">
                  <gloss>bar</gloss>
                  <desc>10⁵ Pa</desc>
                </valItem>
                <valItem ident="Å">
                  <gloss>ångström</gloss>
                  <desc>10⁻¹⁰ m</desc>
                </valItem>
                <!-- selected prefixed base SI units -->
                <valItem ident="g">
                  <gloss>gram</gloss>
                  <desc>unit of mass</desc>
                </valItem>
                <valItem ident="mL">
                  <gloss>millilitre</gloss>
                </valItem>
                <valItem ident="cm">
                  <gloss>centimetre</gloss>
                </valItem>
                <valItem ident="dB">
                  <gloss>decibel</gloss>
                  <desc>see remarks, below</desc>
                </valItem>
                <valItem ident="ns">
                  <gloss>nanosecond</gloss>
                </valItem>
                <!-- units for measuring storage sizes inside a computer -->
                <valItem ident="kbit">
                  <gloss>kilobit</gloss>
                  <desc>10³ or 1000 bits</desc>
                </valItem>
                <valItem ident="Kibit">
                  <gloss>kibibit</gloss>
                  <desc>2¹⁰ or 1024 bits</desc>
                </valItem>
                <valItem ident="Mbit">
                  <gloss>megabit</gloss>
                  <desc>10⁶ or 1 000 000 bits</desc>
                </valItem>
                <valItem ident="Mibit">
                  <gloss>mebibit</gloss>
                  <desc>2²⁰ or 1 048 576 bits</desc>
                </valItem>
                <valItem ident="Gbit">
                  <gloss>gigabit</gloss>
                  <desc>10⁹ or 1 000 000 000 bits</desc>
                </valItem>
                <valItem ident="Gibit">
                  <gloss>gibibit</gloss>
                  <desc>2³⁰ or 1 073 741 824
                  bits</desc>
                </valItem>
                <valItem ident="Tbit">
                  <gloss>terabit</gloss>
                  <desc>10¹² bits</desc>
                </valItem>
                <valItem ident="Tibit">
                  <gloss>tebibit</gloss>
                  <desc>2⁴⁰ bits</desc>
                </valItem>
                <valItem ident="kB">
                  <gloss>kilobyte</gloss>
                  <desc>10³ or 1000 bytes</desc>
                </valItem>
                <valItem ident="KiB">
                  <gloss>kibibyte</gloss>
                  <desc>2¹⁰ or 1024 bytes</desc>
                </valItem>
                <valItem ident="MB">
                  <gloss>megabyte</gloss>
                  <desc>10⁶ or 1 000 000 bytes</desc>
                </valItem>
                <valItem ident="MiB">
                  <gloss>mebibyte</gloss>
                  <desc>2²⁰ or 1 048 576 bytes</desc>
                </valItem>
                <valItem ident="GB">
                  <gloss>gigabyte</gloss>
                  <desc>10⁹ or 1 000 000 000
                  bytes</desc>
                </valItem>
                <valItem ident="GiB">
                  <gloss>gibibyte</gloss>
                  <desc>2³⁰ or 1 073 741 824
                  bytes</desc>
                </valItem>
                <valItem ident="TB">
                  <gloss>terabyte</gloss>
                  <desc>10¹² bytes</desc>
                </valItem>
                <valItem ident="TiB">
                  <gloss>tebibyte</gloss>
                  <desc>2⁴⁰ bytes</desc>
                </valItem>
              </valList>
              <remarks>
                <p>If the measurement being represented is not
                expressed in a particular unit, but rather is a number
                of discrete items, the unit <val>count</val> should be
                used, or the <att>unit</att> attribute may be left
                unspecified.</p>
                <p>Wherever appropriate, a recognised SI unit name
                should be used (see further <ptr target="http://www.bipm.org/en/si/"/>; <ptr target="http://physics.nist.gov/cuu/Units/"/>). The
                list above is indicative rather than exhaustive.</p>
                <p>The symbol <mentioned>B</mentioned> should be used
                to indicate a bel only when prefixed by a symbol
                indicating a factor less than one; it should be used
                to indicate a byte when used alone or when prefixed by
                an SI symbol idicating a factor greater than one or by
                an IEC symbol indicating a binary factor. If the unit
                bel needs to be indicated in combination with a symbol
                indicating a facter greater than one, the entire unit
                should be spelled out, as in <val>kbel</val> (10,000
                decibels) or <val>Mbel</val> (10⁷ decibels).</p>
              </remarks>
            </attDef>
          </attList>
        </classSpec>
        <classSpec ident="att.tableDecoration" mode="change" module="figures" type="atts">
          <attList>
            <attDef ident="role" mode="change">
              <desc>indicates the kind of information held in this cell or&#xD; in each cell of
              this row.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <defaultVal>data</defaultVal>
              <valList type="closed" mode="replace">
                <valItem ident="label">
                  <desc>labelling or descriptive information only.</desc>
                </valItem>
                <valItem ident="data">
                  <desc>data values.</desc>
                </valItem>
              </valList>
            </attDef>
          </attList>
        </classSpec>

        <!-- ********************** -->
        <!-- miscellaneous section  -->
        <!-- ********************** -->
        <!-- Insist that <salute> go in <opener> or <closer> -->
        <!-- (by removing it from model.divWrapper) -->
        <elementSpec ident="salute" module="textstructure" mode="change">
          <classes mode="change">
            <memberOf key="model.divWrapper" mode="delete"/>
          </classes>
        </elementSpec>
        <!-- Insist that <signed> go in <opener> or <closer> -->
        <!-- (by removing it from model.divTopPart and model.divBottomPart) -->
        <elementSpec ident="signed" module="textstructure" mode="change">
          <classes mode="change">
            <memberOf key="model.divBottomPart" mode="delete"/>
            <memberOf key="model.divTopPart" mode="delete"/>
          </classes>
        </elementSpec>
        <!-- constrain where <orig>s are allowed -->
        <elementSpec ident="orig" module="core" mode="change">
          <constraintSpec scheme="schematron" ident="orig-not-belong">
            <constraint>
              <sch:report test="ancestor::wwp:mw">An <gi>orig</gi> should not be inside an <gi>mw</gi></sch:report>
              <sch:report test="ancestor::wwp:orig" role="warning">Generally speaking, an <gi>orig</gi> should not be within an <gi>orig</gi></sch:report>
            </constraint>
          </constraintSpec>
        </elementSpec>
        <!-- Add <linkGrp> and <altGrp> to <hyperDiv>: -->
        <elementSpec ident="linkGrp" module="linking" mode="change">
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="att.pointing.group"/>
            <memberOf key="model.hyperDivPart"/>
          </classes>
        </elementSpec>
        <elementSpec ident="altGrp" module="linking" mode="change">
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="att.pointing.group"/>
            <memberOf key="model.hyperDivPart"/>
          </classes>
        </elementSpec>
        <elementSpec ident="q" module="core" mode="change">
          <attList>
            <attDef ident="type" mode="change">
              <desc>may be used to indicate whether the quoted matter is spoken&#xD; or thought,
              or to characterize it more finely.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.enumerated"/></datatype>
              <valList type="closed" mode="replace">
                <valItem ident="spoken">
                  <desc>representation of direct speech, usually
                  marked by quotation marks.</desc>
                </valItem>
                <valItem ident="thought">
                  <desc>representation of thought, e.g. internal monologue.</desc>
                </valItem>
              </valList>
            </attDef>
            <attDef ident="direct" mode="change">
              <desc>may be used to indicate whether the quoted matter is regarded&#xD; as direct
              or indirect speech.</desc>
              <datatype minOccurs="1" maxOccurs="1"><dataRef key="teidata.xTruthValue"/></datatype>
              <defaultVal>unknown</defaultVal>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="vuji" mode="add">
          <desc>shorthand for <gi>orig</gi> and <gi>reg</gi> (in <gi>choice</gi>) for VUJI phenomena</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.pPart.transcriptional"/>
          </classes>
          <content>
            <!-- Use old-fashioned <rng:choice>, because Stylesheets/ code for newer, better <valList> -->
            <!-- does not work, at least for now. See Stylesheets/ ticket #154. -->
            <rng:choice>
              <rng:value>v</rng:value>
              <rng:value>V</rng:value>
              <rng:value>u</rng:value>
              <rng:value>U</rng:value>
              <rng:value>j</rng:value>
              <rng:value>J</rng:value>
              <rng:value>i</rng:value>
              <rng:value>I</rng:value>
              <rng:value>vv</rng:value>
              <rng:value>VV</rng:value>
              <rng:value>Vv</rng:value>
            </rng:choice>
            <!-- valList type="closed">
              <valItem ident="v"/>
              <valItem ident="V"/>
              <valItem ident="u"/>
              <valItem ident="U"/>
              <valItem ident="j"/>
              <valItem ident="J"/>
              <valItem ident="i"/>
              <valItem ident="I"/>
              <valItem ident="vv"/>
              <valItem ident="Vv"/>
              <valItem ident="VV"/>
            </valList -->
          </content>
          <remarks>
            <p>This element is syntactic sugar for a <gi>choice</gi>
            element whose child <gi>orig</gi> contains the content
            of this <gi>vuji</gi>, and whose child <gi>reg</gi>
            contains the regularized version thereof. I.e.
            <table>
              <row>
                <cell><gi>vuji</gi> content</cell>
                <cell>converted <gi>orig</gi></cell>
                <cell>converted <gi>reg</gi></cell>
              </row>
              <row>
                <cell>v</cell>
                <cell>v</cell>
                <cell>u</cell>
              </row>
              <row>
                <cell>V</cell>
                <cell>V</cell>
                <cell>U</cell>
              </row>
              <row>
                <cell>u</cell>
                <cell>u</cell>
                <cell>v</cell>
              </row>
              <row>
                <cell>U</cell>
                <cell>U</cell>
                <cell>V</cell>
              </row>
              <row>
                <cell>j</cell>
                <cell>j</cell>
                <cell>i</cell>
              </row>
              <row>
                <cell>J</cell>
                <cell>J</cell>
                <cell>I</cell>
              </row>
              <row>
                <cell>i</cell>
                <cell>i</cell>
                <cell>j</cell>
              </row>
              <row>
                <cell>I</cell>
                <cell>I</cell>
                <cell>J</cell>
              </row>
              <row>
                <cell>vv</cell>
                <cell>vv</cell>
                <cell>w</cell>
              </row>
              <row>
                <cell>VV</cell>
                <cell>VV</cell>
                <cell>W</cell>
              </row>
            </table> Thus in general what you see on the page should
            be the content of <gi>vuji</gi>.</p>
          </remarks>
        </elementSpec>

        <!-- **************** -->
        <!-- XInclude section -->
        <!-- **************** -->
        <elementSpec ident="include" ns="http://www.w3.org/2001/XInclude" mode="add">
          <desc>The W3C XInclude element</desc>
          <classes mode="replace">
            <memberOf key="att.global"/>
            <memberOf key="model.publicationStmtPart.detail"/>
            <memberOf key="model.encodingDescPart"/>
            <memberOf key="model.profileDescPart"/>
          </classes>
          <content>
            <elementRef key="fallback" minOccurs="0"/>
          </content>
          <attList>
            <attDef ident="href">
              <desc>pointer to the resource being included</desc>
              <datatype><dataRef key="teidata.pointer"/></datatype>
            </attDef>
            <attDef ident="parse" usage="opt">
              <defaultVal>xml</defaultVal>
              <valList type="closed">
                <valItem ident="xml"/>
                <valItem ident="text"/>
              </valList>
            </attDef>
            <attDef ident="xpointer" usage="opt">
              <datatype> <dataRef key="teidata.text"/> </datatype>
            </attDef>
            <attDef ident="encoding" usage="opt">
              <datatype> <dataRef key="teidata.text"/> </datatype>
            </attDef>
            <attDef ident="accept" usage="opt">
              <datatype> <dataRef key="teidata.text"/> </datatype>
            </attDef>
            <attDef ident="accept-charset" usage="opt">
              <datatype> <dataRef key="teidata.text"/> </datatype>
            </attDef>
            <attDef ident="accept-language" usage="opt">
              <datatype> <dataRef key="teidata.text"/> </datatype>
            </attDef>
          </attList>
        </elementSpec>
        <elementSpec ident="fallback" ns="http://www.w3.org/2001/XInclude" mode="add">
          <desc>Wrapper for fallback elements if an XInclude fails</desc>
          <content>
            <anyElement/>
          </content>
        </elementSpec>

      </schemaSpec>
    </body>
  </text>
</TEI>
